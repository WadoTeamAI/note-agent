"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/chevrotain-allstar";
exports.ids = ["vendor-chunks/chevrotain-allstar"];
exports.modules = {

/***/ "(ssr)/./node_modules/chevrotain-allstar/lib/all-star-lookahead.js":
/*!*******************************************************************!*\
  !*** ./node_modules/chevrotain-allstar/lib/all-star-lookahead.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LLStarLookaheadStrategy: () => (/* binding */ LLStarLookaheadStrategy)\n/* harmony export */ });\n/* harmony import */ var chevrotain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chevrotain */ \"(ssr)/./node_modules/chevrotain/lib/src/api.js\");\n/* harmony import */ var _atn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./atn.js */ \"(ssr)/./node_modules/chevrotain-allstar/lib/atn.js\");\n/* harmony import */ var _dfa_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dfa.js */ \"(ssr)/./node_modules/chevrotain-allstar/lib/dfa.js\");\n/* harmony import */ var lodash_es_min_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash-es/min.js */ \"(ssr)/./node_modules/lodash-es/min.js\");\n/* harmony import */ var lodash_es_flatMap_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash-es/flatMap.js */ \"(ssr)/./node_modules/lodash-es/flatMap.js\");\n/* harmony import */ var lodash_es_uniqBy_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash-es/uniqBy.js */ \"(ssr)/./node_modules/lodash-es/uniqBy.js\");\n/* harmony import */ var lodash_es_map_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es/map.js */ \"(ssr)/./node_modules/lodash-es/map.js\");\n/* harmony import */ var lodash_es_flatten_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash-es/flatten.js */ \"(ssr)/./node_modules/lodash-es/flatten.js\");\n/* harmony import */ var lodash_es_forEach_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es/forEach.js */ \"(ssr)/./node_modules/lodash-es/forEach.js\");\n/* harmony import */ var lodash_es_isEmpty_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash-es/isEmpty.js */ \"(ssr)/./node_modules/lodash-es/isEmpty.js\");\n/* harmony import */ var lodash_es_reduce_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es/reduce.js */ \"(ssr)/./node_modules/lodash-es/reduce.js\");\n/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\n\n\n\n\n\n\nfunction createDFACache(startState, decision) {\n    const map = {};\n    return (predicateSet) => {\n        const key = predicateSet.toString();\n        let existing = map[key];\n        if (existing !== undefined) {\n            return existing;\n        }\n        else {\n            existing = {\n                atnStartState: startState,\n                decision,\n                states: {}\n            };\n            map[key] = existing;\n            return existing;\n        }\n    };\n}\nclass PredicateSet {\n    constructor() {\n        this.predicates = [];\n    }\n    is(index) {\n        return index >= this.predicates.length || this.predicates[index];\n    }\n    set(index, value) {\n        this.predicates[index] = value;\n    }\n    toString() {\n        let value = \"\";\n        const size = this.predicates.length;\n        for (let i = 0; i < size; i++) {\n            value += this.predicates[i] === true ? \"1\" : \"0\";\n        }\n        return value;\n    }\n}\nconst EMPTY_PREDICATES = new PredicateSet();\nclass LLStarLookaheadStrategy extends chevrotain__WEBPACK_IMPORTED_MODULE_0__.LLkLookaheadStrategy {\n    constructor(options) {\n        var _a;\n        super();\n        this.logging = (_a = options === null || options === void 0 ? void 0 : options.logging) !== null && _a !== void 0 ? _a : ((message) => console.log(message));\n    }\n    initialize(options) {\n        this.atn = (0,_atn_js__WEBPACK_IMPORTED_MODULE_1__.createATN)(options.rules);\n        this.dfas = initATNSimulator(this.atn);\n    }\n    validateAmbiguousAlternationAlternatives() {\n        return [];\n    }\n    validateEmptyOrAlternatives() {\n        return [];\n    }\n    buildLookaheadForAlternation(options) {\n        const { prodOccurrence, rule, hasPredicates, dynamicTokensEnabled } = options;\n        const dfas = this.dfas;\n        const logging = this.logging;\n        const key = (0,_atn_js__WEBPACK_IMPORTED_MODULE_1__.buildATNKey)(rule, 'Alternation', prodOccurrence);\n        const decisionState = this.atn.decisionMap[key];\n        const decisionIndex = decisionState.decision;\n        const partialAlts = (0,lodash_es_map_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])((0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.getLookaheadPaths)({\n            maxLookahead: 1,\n            occurrence: prodOccurrence,\n            prodType: \"Alternation\",\n            rule: rule\n        }), (currAlt) => (0,lodash_es_map_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(currAlt, (path) => path[0]));\n        if (isLL1Sequence(partialAlts, false) && !dynamicTokensEnabled) {\n            const choiceToAlt = (0,lodash_es_reduce_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(partialAlts, (result, currAlt, idx) => {\n                (0,lodash_es_forEach_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(currAlt, (currTokType) => {\n                    if (currTokType) {\n                        result[currTokType.tokenTypeIdx] = idx;\n                        (0,lodash_es_forEach_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(currTokType.categoryMatches, (currExtendingType) => {\n                            result[currExtendingType] = idx;\n                        });\n                    }\n                });\n                return result;\n            }, {});\n            if (hasPredicates) {\n                return function (orAlts) {\n                    var _a;\n                    const nextToken = this.LA(1);\n                    const prediction = choiceToAlt[nextToken.tokenTypeIdx];\n                    if (orAlts !== undefined && prediction !== undefined) {\n                        const gate = (_a = orAlts[prediction]) === null || _a === void 0 ? void 0 : _a.GATE;\n                        if (gate !== undefined && gate.call(this) === false) {\n                            return undefined;\n                        }\n                    }\n                    return prediction;\n                };\n            }\n            else {\n                return function () {\n                    const nextToken = this.LA(1);\n                    return choiceToAlt[nextToken.tokenTypeIdx];\n                };\n            }\n        }\n        else if (hasPredicates) {\n            return function (orAlts) {\n                const predicates = new PredicateSet();\n                const length = orAlts === undefined ? 0 : orAlts.length;\n                for (let i = 0; i < length; i++) {\n                    const gate = orAlts === null || orAlts === void 0 ? void 0 : orAlts[i].GATE;\n                    predicates.set(i, gate === undefined || gate.call(this));\n                }\n                const result = adaptivePredict.call(this, dfas, decisionIndex, predicates, logging);\n                return typeof result === 'number' ? result : undefined;\n            };\n        }\n        else {\n            return function () {\n                const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);\n                return typeof result === 'number' ? result : undefined;\n            };\n        }\n    }\n    buildLookaheadForOptional(options) {\n        const { prodOccurrence, rule, prodType, dynamicTokensEnabled } = options;\n        const dfas = this.dfas;\n        const logging = this.logging;\n        const key = (0,_atn_js__WEBPACK_IMPORTED_MODULE_1__.buildATNKey)(rule, prodType, prodOccurrence);\n        const decisionState = this.atn.decisionMap[key];\n        const decisionIndex = decisionState.decision;\n        const alts = (0,lodash_es_map_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])((0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.getLookaheadPaths)({\n            maxLookahead: 1,\n            occurrence: prodOccurrence,\n            prodType,\n            rule\n        }), (e) => {\n            return (0,lodash_es_map_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(e, (g) => g[0]);\n        });\n        if (isLL1Sequence(alts) && alts[0][0] && !dynamicTokensEnabled) {\n            const alt = alts[0];\n            const singleTokensTypes = (0,lodash_es_flatten_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(alt);\n            if (singleTokensTypes.length === 1 &&\n                (0,lodash_es_isEmpty_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(singleTokensTypes[0].categoryMatches)) {\n                const expectedTokenType = singleTokensTypes[0];\n                const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;\n                return function () {\n                    return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;\n                };\n            }\n            else {\n                const choiceToAlt = (0,lodash_es_reduce_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(singleTokensTypes, (result, currTokType) => {\n                    if (currTokType !== undefined) {\n                        result[currTokType.tokenTypeIdx] = true;\n                        (0,lodash_es_forEach_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(currTokType.categoryMatches, (currExtendingType) => {\n                            result[currExtendingType] = true;\n                        });\n                    }\n                    return result;\n                }, {});\n                return function () {\n                    const nextToken = this.LA(1);\n                    return choiceToAlt[nextToken.tokenTypeIdx] === true;\n                };\n            }\n        }\n        return function () {\n            const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);\n            return typeof result === \"object\" ? false : result === 0;\n        };\n    }\n}\nfunction isLL1Sequence(sequences, allowEmpty = true) {\n    const fullSet = new Set();\n    for (const alt of sequences) {\n        const altSet = new Set();\n        for (const tokType of alt) {\n            if (tokType === undefined) {\n                if (allowEmpty) {\n                    // Epsilon production encountered\n                    break;\n                }\n                else {\n                    return false;\n                }\n            }\n            const indices = [tokType.tokenTypeIdx].concat(tokType.categoryMatches);\n            for (const index of indices) {\n                if (fullSet.has(index)) {\n                    if (!altSet.has(index)) {\n                        return false;\n                    }\n                }\n                else {\n                    fullSet.add(index);\n                    altSet.add(index);\n                }\n            }\n        }\n    }\n    return true;\n}\nfunction initATNSimulator(atn) {\n    const decisionLength = atn.decisionStates.length;\n    const decisionToDFA = Array(decisionLength);\n    for (let i = 0; i < decisionLength; i++) {\n        decisionToDFA[i] = createDFACache(atn.decisionStates[i], i);\n    }\n    return decisionToDFA;\n}\nfunction adaptivePredict(dfaCaches, decision, predicateSet, logging) {\n    const dfa = dfaCaches[decision](predicateSet);\n    let start = dfa.start;\n    if (start === undefined) {\n        const closure = computeStartState(dfa.atnStartState);\n        start = addDFAState(dfa, newDFAState(closure));\n        dfa.start = start;\n    }\n    const alt = performLookahead.apply(this, [dfa, start, predicateSet, logging]);\n    return alt;\n}\nfunction performLookahead(dfa, s0, predicateSet, logging) {\n    let previousD = s0;\n    let i = 1;\n    const path = [];\n    let t = this.LA(i++);\n    while (true) {\n        let d = getExistingTargetState(previousD, t);\n        if (d === undefined) {\n            d = computeLookaheadTarget.apply(this, [dfa, previousD, t, i, predicateSet, logging]);\n        }\n        if (d === _dfa_js__WEBPACK_IMPORTED_MODULE_2__.DFA_ERROR) {\n            return buildAdaptivePredictError(path, previousD, t);\n        }\n        if (d.isAcceptState === true) {\n            return d.prediction;\n        }\n        previousD = d;\n        path.push(t);\n        t = this.LA(i++);\n    }\n}\nfunction computeLookaheadTarget(dfa, previousD, token, lookahead, predicateSet, logging) {\n    const reach = computeReachSet(previousD.configs, token, predicateSet);\n    if (reach.size === 0) {\n        addDFAEdge(dfa, previousD, token, _dfa_js__WEBPACK_IMPORTED_MODULE_2__.DFA_ERROR);\n        return _dfa_js__WEBPACK_IMPORTED_MODULE_2__.DFA_ERROR;\n    }\n    let newState = newDFAState(reach);\n    const predictedAlt = getUniqueAlt(reach, predicateSet);\n    if (predictedAlt !== undefined) {\n        newState.isAcceptState = true;\n        newState.prediction = predictedAlt;\n        newState.configs.uniqueAlt = predictedAlt;\n    }\n    else if (hasConflictTerminatingPrediction(reach)) {\n        const prediction = (0,lodash_es_min_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(reach.alts);\n        newState.isAcceptState = true;\n        newState.prediction = prediction;\n        newState.configs.uniqueAlt = prediction;\n        reportLookaheadAmbiguity.apply(this, [dfa, lookahead, reach.alts, logging]);\n    }\n    newState = addDFAEdge(dfa, previousD, token, newState);\n    return newState;\n}\nfunction reportLookaheadAmbiguity(dfa, lookahead, ambiguityIndices, logging) {\n    const prefixPath = [];\n    for (let i = 1; i <= lookahead; i++) {\n        prefixPath.push(this.LA(i).tokenType);\n    }\n    const atnState = dfa.atnStartState;\n    const topLevelRule = atnState.rule;\n    const production = atnState.production;\n    const message = buildAmbiguityError({\n        topLevelRule,\n        ambiguityIndices,\n        production,\n        prefixPath\n    });\n    logging(message);\n}\nfunction buildAmbiguityError(options) {\n    const pathMsg = (0,lodash_es_map_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(options.prefixPath, (currtok) => (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenLabel)(currtok)).join(\", \");\n    const occurrence = options.production.idx === 0 ? \"\" : options.production.idx;\n    let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\", \")}> in <${getProductionDslName(options.production)}${occurrence}>` +\n        ` inside <${options.topLevelRule.name}> Rule,\\n` +\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`;\n    currMessage =\n        currMessage +\n            `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` +\n            `For Further details.`;\n    return currMessage;\n}\nfunction getProductionDslName(prod) {\n    if (prod instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.NonTerminal) {\n        return \"SUBRULE\";\n    }\n    else if (prod instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.Option) {\n        return \"OPTION\";\n    }\n    else if (prod instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.Alternation) {\n        return \"OR\";\n    }\n    else if (prod instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatory) {\n        return \"AT_LEAST_ONE\";\n    }\n    else if (prod instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatoryWithSeparator) {\n        return \"AT_LEAST_ONE_SEP\";\n    }\n    else if (prod instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.RepetitionWithSeparator) {\n        return \"MANY_SEP\";\n    }\n    else if (prod instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.Repetition) {\n        return \"MANY\";\n    }\n    else if (prod instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.Terminal) {\n        return \"CONSUME\";\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction buildAdaptivePredictError(path, previous, current) {\n    const nextTransitions = (0,lodash_es_flatMap_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(previous.configs.elements, (e) => e.state.transitions);\n    const nextTokenTypes = (0,lodash_es_uniqBy_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(nextTransitions\n        .filter((e) => e instanceof _atn_js__WEBPACK_IMPORTED_MODULE_1__.AtomTransition)\n        .map((e) => e.tokenType), (e) => e.tokenTypeIdx);\n    return {\n        actualToken: current,\n        possibleTokenTypes: nextTokenTypes,\n        tokenPath: path\n    };\n}\nfunction getExistingTargetState(state, token) {\n    return state.edges[token.tokenTypeIdx];\n}\nfunction computeReachSet(configs, token, predicateSet) {\n    const intermediate = new _dfa_js__WEBPACK_IMPORTED_MODULE_2__.ATNConfigSet();\n    const skippedStopStates = [];\n    for (const c of configs.elements) {\n        if (predicateSet.is(c.alt) === false) {\n            continue;\n        }\n        if (c.state.type === _atn_js__WEBPACK_IMPORTED_MODULE_1__.ATN_RULE_STOP) {\n            skippedStopStates.push(c);\n            continue;\n        }\n        const transitionLength = c.state.transitions.length;\n        for (let i = 0; i < transitionLength; i++) {\n            const transition = c.state.transitions[i];\n            const target = getReachableTarget(transition, token);\n            if (target !== undefined) {\n                intermediate.add({\n                    state: target,\n                    alt: c.alt,\n                    stack: c.stack\n                });\n            }\n        }\n    }\n    let reach;\n    if (skippedStopStates.length === 0 && intermediate.size === 1) {\n        reach = intermediate;\n    }\n    if (reach === undefined) {\n        reach = new _dfa_js__WEBPACK_IMPORTED_MODULE_2__.ATNConfigSet();\n        for (const c of intermediate.elements) {\n            closure(c, reach);\n        }\n    }\n    if (skippedStopStates.length > 0 && !hasConfigInRuleStopState(reach)) {\n        for (const c of skippedStopStates) {\n            reach.add(c);\n        }\n    }\n    return reach;\n}\nfunction getReachableTarget(transition, token) {\n    if (transition instanceof _atn_js__WEBPACK_IMPORTED_MODULE_1__.AtomTransition &&\n        (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(token, transition.tokenType)) {\n        return transition.target;\n    }\n    return undefined;\n}\nfunction getUniqueAlt(configs, predicateSet) {\n    let alt;\n    for (const c of configs.elements) {\n        if (predicateSet.is(c.alt) === true) {\n            if (alt === undefined) {\n                alt = c.alt;\n            }\n            else if (alt !== c.alt) {\n                return undefined;\n            }\n        }\n    }\n    return alt;\n}\nfunction newDFAState(closure) {\n    return {\n        configs: closure,\n        edges: {},\n        isAcceptState: false,\n        prediction: -1\n    };\n}\nfunction addDFAEdge(dfa, from, token, to) {\n    to = addDFAState(dfa, to);\n    from.edges[token.tokenTypeIdx] = to;\n    return to;\n}\nfunction addDFAState(dfa, state) {\n    if (state === _dfa_js__WEBPACK_IMPORTED_MODULE_2__.DFA_ERROR) {\n        return state;\n    }\n    // Repetitions have the same config set\n    // Therefore, storing the key of the config in a map allows us to create a loop in our DFA\n    const mapKey = state.configs.key;\n    const existing = dfa.states[mapKey];\n    if (existing !== undefined) {\n        return existing;\n    }\n    state.configs.finalize();\n    dfa.states[mapKey] = state;\n    return state;\n}\nfunction computeStartState(atnState) {\n    const configs = new _dfa_js__WEBPACK_IMPORTED_MODULE_2__.ATNConfigSet();\n    const numberOfTransitions = atnState.transitions.length;\n    for (let i = 0; i < numberOfTransitions; i++) {\n        const target = atnState.transitions[i].target;\n        const config = {\n            state: target,\n            alt: i,\n            stack: []\n        };\n        closure(config, configs);\n    }\n    return configs;\n}\nfunction closure(config, configs) {\n    const p = config.state;\n    if (p.type === _atn_js__WEBPACK_IMPORTED_MODULE_1__.ATN_RULE_STOP) {\n        if (config.stack.length > 0) {\n            const atnStack = [...config.stack];\n            const followState = atnStack.pop();\n            const followConfig = {\n                state: followState,\n                alt: config.alt,\n                stack: atnStack\n            };\n            closure(followConfig, configs);\n        }\n        else {\n            // Dipping into outer context, simply add the config\n            // This will stop computation once every config is at the rule stop state\n            configs.add(config);\n        }\n        return;\n    }\n    if (!p.epsilonOnlyTransitions) {\n        configs.add(config);\n    }\n    const transitionLength = p.transitions.length;\n    for (let i = 0; i < transitionLength; i++) {\n        const transition = p.transitions[i];\n        const c = getEpsilonTarget(config, transition);\n        if (c !== undefined) {\n            closure(c, configs);\n        }\n    }\n}\nfunction getEpsilonTarget(config, transition) {\n    if (transition instanceof _atn_js__WEBPACK_IMPORTED_MODULE_1__.EpsilonTransition) {\n        return {\n            state: transition.target,\n            alt: config.alt,\n            stack: config.stack\n        };\n    }\n    else if (transition instanceof _atn_js__WEBPACK_IMPORTED_MODULE_1__.RuleTransition) {\n        const stack = [...config.stack, transition.followState];\n        return {\n            state: transition.target,\n            alt: config.alt,\n            stack\n        };\n    }\n    return undefined;\n}\nfunction hasConfigInRuleStopState(configs) {\n    for (const c of configs.elements) {\n        if (c.state.type === _atn_js__WEBPACK_IMPORTED_MODULE_1__.ATN_RULE_STOP) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction allConfigsInRuleStopStates(configs) {\n    for (const c of configs.elements) {\n        if (c.state.type !== _atn_js__WEBPACK_IMPORTED_MODULE_1__.ATN_RULE_STOP) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction hasConflictTerminatingPrediction(configs) {\n    if (allConfigsInRuleStopStates(configs)) {\n        return true;\n    }\n    const altSets = getConflictingAltSets(configs.elements);\n    const heuristic = hasConflictingAltSet(altSets) && !hasStateAssociatedWithOneAlt(altSets);\n    return heuristic;\n}\nfunction getConflictingAltSets(configs) {\n    const configToAlts = new Map();\n    for (const c of configs) {\n        const key = (0,_dfa_js__WEBPACK_IMPORTED_MODULE_2__.getATNConfigKey)(c, false);\n        let alts = configToAlts.get(key);\n        if (alts === undefined) {\n            alts = {};\n            configToAlts.set(key, alts);\n        }\n        alts[c.alt] = true;\n    }\n    return configToAlts;\n}\nfunction hasConflictingAltSet(altSets) {\n    for (const value of Array.from(altSets.values())) {\n        if (Object.keys(value).length > 1) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction hasStateAssociatedWithOneAlt(altSets) {\n    for (const value of Array.from(altSets.values())) {\n        if (Object.keys(value).length === 1) {\n            return true;\n        }\n    }\n    return false;\n}\n//# sourceMappingURL=all-star-lookahead.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi1hbGxzdGFyL2xpYi9hbGwtc3Rhci1sb29rYWhlYWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN1TztBQUNuSDtBQUNoRDtBQUNqQztBQUNRO0FBQ0Y7QUFDTjtBQUNRO0FBQ0E7QUFDQTtBQUNGO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxzQ0FBc0MsNERBQW9CO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNERBQTREO0FBQzVFO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQVc7QUFDL0I7QUFDQTtBQUNBLDRCQUE0Qiw0REFBRyxDQUFDLDZEQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0JBQWdCLDREQUFHO0FBQzVCO0FBQ0EsZ0NBQWdDLCtEQUFNO0FBQ3RDLGdCQUFnQixnRUFBTztBQUN2QjtBQUNBO0FBQ0Esd0JBQXdCLGdFQUFPO0FBQy9CO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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YTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3REFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbmFrYWlrZW50by9ub3RlLWFnZW50L25vZGVfbW9kdWxlcy9jaGV2cm90YWluLWFsbHN0YXIvbGliL2FsbC1zdGFyLWxvb2thaGVhZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMiBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyB0b2tlbk1hdGNoZXIsIHRva2VuTGFiZWwsIE5vblRlcm1pbmFsLCBBbHRlcm5hdGlvbiwgT3B0aW9uLCBSZXBldGl0aW9uTWFuZGF0b3J5LCBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciwgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IsIFJlcGV0aXRpb24sIFRlcm1pbmFsLCBMTGtMb29rYWhlYWRTdHJhdGVneSwgZ2V0TG9va2FoZWFkUGF0aHMgfSBmcm9tIFwiY2hldnJvdGFpblwiO1xuaW1wb3J0IHsgQVROX1JVTEVfU1RPUCwgQXRvbVRyYW5zaXRpb24sIGJ1aWxkQVROS2V5LCBjcmVhdGVBVE4sIEVwc2lsb25UcmFuc2l0aW9uLCBSdWxlVHJhbnNpdGlvbiB9IGZyb20gXCIuL2F0bi5qc1wiO1xuaW1wb3J0IHsgQVROQ29uZmlnU2V0LCBERkFfRVJST1IsIGdldEFUTkNvbmZpZ0tleSB9IGZyb20gXCIuL2RmYS5qc1wiO1xuaW1wb3J0IG1pbiBmcm9tIFwibG9kYXNoLWVzL21pbi5qc1wiO1xuaW1wb3J0IGZsYXRNYXAgZnJvbSBcImxvZGFzaC1lcy9mbGF0TWFwLmpzXCI7XG5pbXBvcnQgdW5pcUJ5IGZyb20gXCJsb2Rhc2gtZXMvdW5pcUJ5LmpzXCI7XG5pbXBvcnQgbWFwIGZyb20gXCJsb2Rhc2gtZXMvbWFwLmpzXCI7XG5pbXBvcnQgZmxhdHRlbiBmcm9tIFwibG9kYXNoLWVzL2ZsYXR0ZW4uanNcIjtcbmltcG9ydCBmb3JFYWNoIGZyb20gXCJsb2Rhc2gtZXMvZm9yRWFjaC5qc1wiO1xuaW1wb3J0IGlzRW1wdHkgZnJvbSBcImxvZGFzaC1lcy9pc0VtcHR5LmpzXCI7XG5pbXBvcnQgcmVkdWNlIGZyb20gXCJsb2Rhc2gtZXMvcmVkdWNlLmpzXCI7XG5mdW5jdGlvbiBjcmVhdGVERkFDYWNoZShzdGFydFN0YXRlLCBkZWNpc2lvbikge1xuICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgIHJldHVybiAocHJlZGljYXRlU2V0KSA9PiB7XG4gICAgICAgIGNvbnN0IGtleSA9IHByZWRpY2F0ZVNldC50b1N0cmluZygpO1xuICAgICAgICBsZXQgZXhpc3RpbmcgPSBtYXBba2V5XTtcbiAgICAgICAgaWYgKGV4aXN0aW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4aXN0aW5nID0ge1xuICAgICAgICAgICAgICAgIGF0blN0YXJ0U3RhdGU6IHN0YXJ0U3RhdGUsXG4gICAgICAgICAgICAgICAgZGVjaXNpb24sXG4gICAgICAgICAgICAgICAgc3RhdGVzOiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1hcFtrZXldID0gZXhpc3Rpbmc7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIH1cbiAgICB9O1xufVxuY2xhc3MgUHJlZGljYXRlU2V0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGVzID0gW107XG4gICAgfVxuICAgIGlzKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSB0aGlzLnByZWRpY2F0ZXMubGVuZ3RoIHx8IHRoaXMucHJlZGljYXRlc1tpbmRleF07XG4gICAgfVxuICAgIHNldChpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGVzW2luZGV4XSA9IHZhbHVlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gXCJcIjtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMucHJlZGljYXRlcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZSArPSB0aGlzLnByZWRpY2F0ZXNbaV0gPT09IHRydWUgPyBcIjFcIiA6IFwiMFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5jb25zdCBFTVBUWV9QUkVESUNBVEVTID0gbmV3IFByZWRpY2F0ZVNldCgpO1xuZXhwb3J0IGNsYXNzIExMU3Rhckxvb2thaGVhZFN0cmF0ZWd5IGV4dGVuZHMgTExrTG9va2FoZWFkU3RyYXRlZ3kge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxvZ2dpbmcgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubG9nZ2luZykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKChtZXNzYWdlKSA9PiBjb25zb2xlLmxvZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGluaXRpYWxpemUob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0biA9IGNyZWF0ZUFUTihvcHRpb25zLnJ1bGVzKTtcbiAgICAgICAgdGhpcy5kZmFzID0gaW5pdEFUTlNpbXVsYXRvcih0aGlzLmF0bik7XG4gICAgfVxuICAgIHZhbGlkYXRlQW1iaWd1b3VzQWx0ZXJuYXRpb25BbHRlcm5hdGl2ZXMoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFsaWRhdGVFbXB0eU9yQWx0ZXJuYXRpdmVzKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGJ1aWxkTG9va2FoZWFkRm9yQWx0ZXJuYXRpb24ob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHByb2RPY2N1cnJlbmNlLCBydWxlLCBoYXNQcmVkaWNhdGVzLCBkeW5hbWljVG9rZW5zRW5hYmxlZCB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgZGZhcyA9IHRoaXMuZGZhcztcbiAgICAgICAgY29uc3QgbG9nZ2luZyA9IHRoaXMubG9nZ2luZztcbiAgICAgICAgY29uc3Qga2V5ID0gYnVpbGRBVE5LZXkocnVsZSwgJ0FsdGVybmF0aW9uJywgcHJvZE9jY3VycmVuY2UpO1xuICAgICAgICBjb25zdCBkZWNpc2lvblN0YXRlID0gdGhpcy5hdG4uZGVjaXNpb25NYXBba2V5XTtcbiAgICAgICAgY29uc3QgZGVjaXNpb25JbmRleCA9IGRlY2lzaW9uU3RhdGUuZGVjaXNpb247XG4gICAgICAgIGNvbnN0IHBhcnRpYWxBbHRzID0gbWFwKGdldExvb2thaGVhZFBhdGhzKHtcbiAgICAgICAgICAgIG1heExvb2thaGVhZDogMSxcbiAgICAgICAgICAgIG9jY3VycmVuY2U6IHByb2RPY2N1cnJlbmNlLFxuICAgICAgICAgICAgcHJvZFR5cGU6IFwiQWx0ZXJuYXRpb25cIixcbiAgICAgICAgICAgIHJ1bGU6IHJ1bGVcbiAgICAgICAgfSksIChjdXJyQWx0KSA9PiBtYXAoY3VyckFsdCwgKHBhdGgpID0+IHBhdGhbMF0pKTtcbiAgICAgICAgaWYgKGlzTEwxU2VxdWVuY2UocGFydGlhbEFsdHMsIGZhbHNlKSAmJiAhZHluYW1pY1Rva2Vuc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNob2ljZVRvQWx0ID0gcmVkdWNlKHBhcnRpYWxBbHRzLCAocmVzdWx0LCBjdXJyQWx0LCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICBmb3JFYWNoKGN1cnJBbHQsIChjdXJyVG9rVHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyclRva1R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtjdXJyVG9rVHlwZS50b2tlblR5cGVJZHhdID0gaWR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yRWFjaChjdXJyVG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMsIChjdXJyRXh0ZW5kaW5nVHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtjdXJyRXh0ZW5kaW5nVHlwZV0gPSBpZHg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICBpZiAoaGFzUHJlZGljYXRlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAob3JBbHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFRva2VuID0gdGhpcy5MQSgxKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZGljdGlvbiA9IGNob2ljZVRvQWx0W25leHRUb2tlbi50b2tlblR5cGVJZHhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3JBbHRzICE9PSB1bmRlZmluZWQgJiYgcHJlZGljdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnYXRlID0gKF9hID0gb3JBbHRzW3ByZWRpY3Rpb25dKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuR0FURTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnYXRlICE9PSB1bmRlZmluZWQgJiYgZ2F0ZS5jYWxsKHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZWRpY3Rpb247XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUb2tlbiA9IHRoaXMuTEEoMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaG9pY2VUb0FsdFtuZXh0VG9rZW4udG9rZW5UeXBlSWR4XTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhc1ByZWRpY2F0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAob3JBbHRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlZGljYXRlcyA9IG5ldyBQcmVkaWNhdGVTZXQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBvckFsdHMgPT09IHVuZGVmaW5lZCA/IDAgOiBvckFsdHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2F0ZSA9IG9yQWx0cyA9PT0gbnVsbCB8fCBvckFsdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yQWx0c1tpXS5HQVRFO1xuICAgICAgICAgICAgICAgICAgICBwcmVkaWNhdGVzLnNldChpLCBnYXRlID09PSB1bmRlZmluZWQgfHwgZ2F0ZS5jYWxsKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYWRhcHRpdmVQcmVkaWN0LmNhbGwodGhpcywgZGZhcywgZGVjaXNpb25JbmRleCwgcHJlZGljYXRlcywgbG9nZ2luZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiByZXN1bHQgPT09ICdudW1iZXInID8gcmVzdWx0IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYWRhcHRpdmVQcmVkaWN0LmNhbGwodGhpcywgZGZhcywgZGVjaXNpb25JbmRleCwgRU1QVFlfUFJFRElDQVRFUywgbG9nZ2luZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiByZXN1bHQgPT09ICdudW1iZXInID8gcmVzdWx0IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBidWlsZExvb2thaGVhZEZvck9wdGlvbmFsKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBwcm9kT2NjdXJyZW5jZSwgcnVsZSwgcHJvZFR5cGUsIGR5bmFtaWNUb2tlbnNFbmFibGVkIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBkZmFzID0gdGhpcy5kZmFzO1xuICAgICAgICBjb25zdCBsb2dnaW5nID0gdGhpcy5sb2dnaW5nO1xuICAgICAgICBjb25zdCBrZXkgPSBidWlsZEFUTktleShydWxlLCBwcm9kVHlwZSwgcHJvZE9jY3VycmVuY2UpO1xuICAgICAgICBjb25zdCBkZWNpc2lvblN0YXRlID0gdGhpcy5hdG4uZGVjaXNpb25NYXBba2V5XTtcbiAgICAgICAgY29uc3QgZGVjaXNpb25JbmRleCA9IGRlY2lzaW9uU3RhdGUuZGVjaXNpb247XG4gICAgICAgIGNvbnN0IGFsdHMgPSBtYXAoZ2V0TG9va2FoZWFkUGF0aHMoe1xuICAgICAgICAgICAgbWF4TG9va2FoZWFkOiAxLFxuICAgICAgICAgICAgb2NjdXJyZW5jZTogcHJvZE9jY3VycmVuY2UsXG4gICAgICAgICAgICBwcm9kVHlwZSxcbiAgICAgICAgICAgIHJ1bGVcbiAgICAgICAgfSksIChlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbWFwKGUsIChnKSA9PiBnWzBdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc0xMMVNlcXVlbmNlKGFsdHMpICYmIGFsdHNbMF1bMF0gJiYgIWR5bmFtaWNUb2tlbnNFbmFibGVkKSB7XG4gICAgICAgICAgICBjb25zdCBhbHQgPSBhbHRzWzBdO1xuICAgICAgICAgICAgY29uc3Qgc2luZ2xlVG9rZW5zVHlwZXMgPSBmbGF0dGVuKGFsdCk7XG4gICAgICAgICAgICBpZiAoc2luZ2xlVG9rZW5zVHlwZXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgICAgaXNFbXB0eShzaW5nbGVUb2tlbnNUeXBlc1swXS5jYXRlZ29yeU1hdGNoZXMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRUb2tlblR5cGUgPSBzaW5nbGVUb2tlbnNUeXBlc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZFRva2VuVW5pcXVlS2V5ID0gZXhwZWN0ZWRUb2tlblR5cGUudG9rZW5UeXBlSWR4O1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkxBKDEpLnRva2VuVHlwZUlkeCA9PT0gZXhwZWN0ZWRUb2tlblVuaXF1ZUtleTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hvaWNlVG9BbHQgPSByZWR1Y2Uoc2luZ2xlVG9rZW5zVHlwZXMsIChyZXN1bHQsIGN1cnJUb2tUeXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyVG9rVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbY3VyclRva1R5cGUudG9rZW5UeXBlSWR4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JFYWNoKGN1cnJUb2tUeXBlLmNhdGVnb3J5TWF0Y2hlcywgKGN1cnJFeHRlbmRpbmdUeXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2N1cnJFeHRlbmRpbmdUeXBlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0VG9rZW4gPSB0aGlzLkxBKDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hvaWNlVG9BbHRbbmV4dFRva2VuLnRva2VuVHlwZUlkeF0gPT09IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYWRhcHRpdmVQcmVkaWN0LmNhbGwodGhpcywgZGZhcywgZGVjaXNpb25JbmRleCwgRU1QVFlfUFJFRElDQVRFUywgbG9nZ2luZyk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHJlc3VsdCA9PT0gXCJvYmplY3RcIiA/IGZhbHNlIDogcmVzdWx0ID09PSAwO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzTEwxU2VxdWVuY2Uoc2VxdWVuY2VzLCBhbGxvd0VtcHR5ID0gdHJ1ZSkge1xuICAgIGNvbnN0IGZ1bGxTZXQgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBhbHQgb2Ygc2VxdWVuY2VzKSB7XG4gICAgICAgIGNvbnN0IGFsdFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCB0b2tUeXBlIG9mIGFsdCkge1xuICAgICAgICAgICAgaWYgKHRva1R5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChhbGxvd0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVwc2lsb24gcHJvZHVjdGlvbiBlbmNvdW50ZXJlZFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gW3Rva1R5cGUudG9rZW5UeXBlSWR4XS5jb25jYXQodG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRpY2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bGxTZXQuaGFzKGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsdFNldC5oYXMoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGxTZXQuYWRkKGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgYWx0U2V0LmFkZChpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaW5pdEFUTlNpbXVsYXRvcihhdG4pIHtcbiAgICBjb25zdCBkZWNpc2lvbkxlbmd0aCA9IGF0bi5kZWNpc2lvblN0YXRlcy5sZW5ndGg7XG4gICAgY29uc3QgZGVjaXNpb25Ub0RGQSA9IEFycmF5KGRlY2lzaW9uTGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY2lzaW9uTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVjaXNpb25Ub0RGQVtpXSA9IGNyZWF0ZURGQUNhY2hlKGF0bi5kZWNpc2lvblN0YXRlc1tpXSwgaSk7XG4gICAgfVxuICAgIHJldHVybiBkZWNpc2lvblRvREZBO1xufVxuZnVuY3Rpb24gYWRhcHRpdmVQcmVkaWN0KGRmYUNhY2hlcywgZGVjaXNpb24sIHByZWRpY2F0ZVNldCwgbG9nZ2luZykge1xuICAgIGNvbnN0IGRmYSA9IGRmYUNhY2hlc1tkZWNpc2lvbl0ocHJlZGljYXRlU2V0KTtcbiAgICBsZXQgc3RhcnQgPSBkZmEuc3RhcnQ7XG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgY2xvc3VyZSA9IGNvbXB1dGVTdGFydFN0YXRlKGRmYS5hdG5TdGFydFN0YXRlKTtcbiAgICAgICAgc3RhcnQgPSBhZGRERkFTdGF0ZShkZmEsIG5ld0RGQVN0YXRlKGNsb3N1cmUpKTtcbiAgICAgICAgZGZhLnN0YXJ0ID0gc3RhcnQ7XG4gICAgfVxuICAgIGNvbnN0IGFsdCA9IHBlcmZvcm1Mb29rYWhlYWQuYXBwbHkodGhpcywgW2RmYSwgc3RhcnQsIHByZWRpY2F0ZVNldCwgbG9nZ2luZ10pO1xuICAgIHJldHVybiBhbHQ7XG59XG5mdW5jdGlvbiBwZXJmb3JtTG9va2FoZWFkKGRmYSwgczAsIHByZWRpY2F0ZVNldCwgbG9nZ2luZykge1xuICAgIGxldCBwcmV2aW91c0QgPSBzMDtcbiAgICBsZXQgaSA9IDE7XG4gICAgY29uc3QgcGF0aCA9IFtdO1xuICAgIGxldCB0ID0gdGhpcy5MQShpKyspO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBkID0gZ2V0RXhpc3RpbmdUYXJnZXRTdGF0ZShwcmV2aW91c0QsIHQpO1xuICAgICAgICBpZiAoZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkID0gY29tcHV0ZUxvb2thaGVhZFRhcmdldC5hcHBseSh0aGlzLCBbZGZhLCBwcmV2aW91c0QsIHQsIGksIHByZWRpY2F0ZVNldCwgbG9nZ2luZ10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkID09PSBERkFfRVJST1IpIHtcbiAgICAgICAgICAgIHJldHVybiBidWlsZEFkYXB0aXZlUHJlZGljdEVycm9yKHBhdGgsIHByZXZpb3VzRCwgdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQuaXNBY2NlcHRTdGF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGQucHJlZGljdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c0QgPSBkO1xuICAgICAgICBwYXRoLnB1c2godCk7XG4gICAgICAgIHQgPSB0aGlzLkxBKGkrKyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZUxvb2thaGVhZFRhcmdldChkZmEsIHByZXZpb3VzRCwgdG9rZW4sIGxvb2thaGVhZCwgcHJlZGljYXRlU2V0LCBsb2dnaW5nKSB7XG4gICAgY29uc3QgcmVhY2ggPSBjb21wdXRlUmVhY2hTZXQocHJldmlvdXNELmNvbmZpZ3MsIHRva2VuLCBwcmVkaWNhdGVTZXQpO1xuICAgIGlmIChyZWFjaC5zaXplID09PSAwKSB7XG4gICAgICAgIGFkZERGQUVkZ2UoZGZhLCBwcmV2aW91c0QsIHRva2VuLCBERkFfRVJST1IpO1xuICAgICAgICByZXR1cm4gREZBX0VSUk9SO1xuICAgIH1cbiAgICBsZXQgbmV3U3RhdGUgPSBuZXdERkFTdGF0ZShyZWFjaCk7XG4gICAgY29uc3QgcHJlZGljdGVkQWx0ID0gZ2V0VW5pcXVlQWx0KHJlYWNoLCBwcmVkaWNhdGVTZXQpO1xuICAgIGlmIChwcmVkaWN0ZWRBbHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdTdGF0ZS5pc0FjY2VwdFN0YXRlID0gdHJ1ZTtcbiAgICAgICAgbmV3U3RhdGUucHJlZGljdGlvbiA9IHByZWRpY3RlZEFsdDtcbiAgICAgICAgbmV3U3RhdGUuY29uZmlncy51bmlxdWVBbHQgPSBwcmVkaWN0ZWRBbHQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhhc0NvbmZsaWN0VGVybWluYXRpbmdQcmVkaWN0aW9uKHJlYWNoKSkge1xuICAgICAgICBjb25zdCBwcmVkaWN0aW9uID0gbWluKHJlYWNoLmFsdHMpO1xuICAgICAgICBuZXdTdGF0ZS5pc0FjY2VwdFN0YXRlID0gdHJ1ZTtcbiAgICAgICAgbmV3U3RhdGUucHJlZGljdGlvbiA9IHByZWRpY3Rpb247XG4gICAgICAgIG5ld1N0YXRlLmNvbmZpZ3MudW5pcXVlQWx0ID0gcHJlZGljdGlvbjtcbiAgICAgICAgcmVwb3J0TG9va2FoZWFkQW1iaWd1aXR5LmFwcGx5KHRoaXMsIFtkZmEsIGxvb2thaGVhZCwgcmVhY2guYWx0cywgbG9nZ2luZ10pO1xuICAgIH1cbiAgICBuZXdTdGF0ZSA9IGFkZERGQUVkZ2UoZGZhLCBwcmV2aW91c0QsIHRva2VuLCBuZXdTdGF0ZSk7XG4gICAgcmV0dXJuIG5ld1N0YXRlO1xufVxuZnVuY3Rpb24gcmVwb3J0TG9va2FoZWFkQW1iaWd1aXR5KGRmYSwgbG9va2FoZWFkLCBhbWJpZ3VpdHlJbmRpY2VzLCBsb2dnaW5nKSB7XG4gICAgY29uc3QgcHJlZml4UGF0aCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGxvb2thaGVhZDsgaSsrKSB7XG4gICAgICAgIHByZWZpeFBhdGgucHVzaCh0aGlzLkxBKGkpLnRva2VuVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGF0blN0YXRlID0gZGZhLmF0blN0YXJ0U3RhdGU7XG4gICAgY29uc3QgdG9wTGV2ZWxSdWxlID0gYXRuU3RhdGUucnVsZTtcbiAgICBjb25zdCBwcm9kdWN0aW9uID0gYXRuU3RhdGUucHJvZHVjdGlvbjtcbiAgICBjb25zdCBtZXNzYWdlID0gYnVpbGRBbWJpZ3VpdHlFcnJvcih7XG4gICAgICAgIHRvcExldmVsUnVsZSxcbiAgICAgICAgYW1iaWd1aXR5SW5kaWNlcyxcbiAgICAgICAgcHJvZHVjdGlvbixcbiAgICAgICAgcHJlZml4UGF0aFxuICAgIH0pO1xuICAgIGxvZ2dpbmcobWVzc2FnZSk7XG59XG5mdW5jdGlvbiBidWlsZEFtYmlndWl0eUVycm9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCBwYXRoTXNnID0gbWFwKG9wdGlvbnMucHJlZml4UGF0aCwgKGN1cnJ0b2spID0+IHRva2VuTGFiZWwoY3VycnRvaykpLmpvaW4oXCIsIFwiKTtcbiAgICBjb25zdCBvY2N1cnJlbmNlID0gb3B0aW9ucy5wcm9kdWN0aW9uLmlkeCA9PT0gMCA/IFwiXCIgOiBvcHRpb25zLnByb2R1Y3Rpb24uaWR4O1xuICAgIGxldCBjdXJyTWVzc2FnZSA9IGBBbWJpZ3VvdXMgQWx0ZXJuYXRpdmVzIERldGVjdGVkOiA8JHtvcHRpb25zLmFtYmlndWl0eUluZGljZXMuam9pbihcIiwgXCIpfT4gaW4gPCR7Z2V0UHJvZHVjdGlvbkRzbE5hbWUob3B0aW9ucy5wcm9kdWN0aW9uKX0ke29jY3VycmVuY2V9PmAgK1xuICAgICAgICBgIGluc2lkZSA8JHtvcHRpb25zLnRvcExldmVsUnVsZS5uYW1lfT4gUnVsZSxcXG5gICtcbiAgICAgICAgYDwke3BhdGhNc2d9PiBtYXkgYXBwZWFycyBhcyBhIHByZWZpeCBwYXRoIGluIGFsbCB0aGVzZSBhbHRlcm5hdGl2ZXMuXFxuYDtcbiAgICBjdXJyTWVzc2FnZSA9XG4gICAgICAgIGN1cnJNZXNzYWdlICtcbiAgICAgICAgICAgIGBTZWU6IGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2d1aWRlL3Jlc29sdmluZ19ncmFtbWFyX2Vycm9ycy5odG1sI0FNQklHVU9VU19BTFRFUk5BVElWRVNcXG5gICtcbiAgICAgICAgICAgIGBGb3IgRnVydGhlciBkZXRhaWxzLmA7XG4gICAgcmV0dXJuIGN1cnJNZXNzYWdlO1xufVxuZnVuY3Rpb24gZ2V0UHJvZHVjdGlvbkRzbE5hbWUocHJvZCkge1xuICAgIGlmIChwcm9kIGluc3RhbmNlb2YgTm9uVGVybWluYWwpIHtcbiAgICAgICAgcmV0dXJuIFwiU1VCUlVMRVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgT3B0aW9uKSB7XG4gICAgICAgIHJldHVybiBcIk9QVElPTlwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgQWx0ZXJuYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIFwiT1JcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnkpIHtcbiAgICAgICAgcmV0dXJuIFwiQVRfTEVBU1RfT05FXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gXCJBVF9MRUFTVF9PTkVfU0VQXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uV2l0aFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gXCJNQU5ZX1NFUFwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbikge1xuICAgICAgICByZXR1cm4gXCJNQU5ZXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICByZXR1cm4gXCJDT05TVU1FXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkQWRhcHRpdmVQcmVkaWN0RXJyb3IocGF0aCwgcHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgICBjb25zdCBuZXh0VHJhbnNpdGlvbnMgPSBmbGF0TWFwKHByZXZpb3VzLmNvbmZpZ3MuZWxlbWVudHMsIChlKSA9PiBlLnN0YXRlLnRyYW5zaXRpb25zKTtcbiAgICBjb25zdCBuZXh0VG9rZW5UeXBlcyA9IHVuaXFCeShuZXh0VHJhbnNpdGlvbnNcbiAgICAgICAgLmZpbHRlcigoZSkgPT4gZSBpbnN0YW5jZW9mIEF0b21UcmFuc2l0aW9uKVxuICAgICAgICAubWFwKChlKSA9PiBlLnRva2VuVHlwZSksIChlKSA9PiBlLnRva2VuVHlwZUlkeCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWN0dWFsVG9rZW46IGN1cnJlbnQsXG4gICAgICAgIHBvc3NpYmxlVG9rZW5UeXBlczogbmV4dFRva2VuVHlwZXMsXG4gICAgICAgIHRva2VuUGF0aDogcGF0aFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRFeGlzdGluZ1RhcmdldFN0YXRlKHN0YXRlLCB0b2tlbikge1xuICAgIHJldHVybiBzdGF0ZS5lZGdlc1t0b2tlbi50b2tlblR5cGVJZHhdO1xufVxuZnVuY3Rpb24gY29tcHV0ZVJlYWNoU2V0KGNvbmZpZ3MsIHRva2VuLCBwcmVkaWNhdGVTZXQpIHtcbiAgICBjb25zdCBpbnRlcm1lZGlhdGUgPSBuZXcgQVROQ29uZmlnU2V0KCk7XG4gICAgY29uc3Qgc2tpcHBlZFN0b3BTdGF0ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGMgb2YgY29uZmlncy5lbGVtZW50cykge1xuICAgICAgICBpZiAocHJlZGljYXRlU2V0LmlzKGMuYWx0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjLnN0YXRlLnR5cGUgPT09IEFUTl9SVUxFX1NUT1ApIHtcbiAgICAgICAgICAgIHNraXBwZWRTdG9wU3RhdGVzLnB1c2goYyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2l0aW9uTGVuZ3RoID0gYy5zdGF0ZS50cmFuc2l0aW9ucy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNpdGlvbkxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2l0aW9uID0gYy5zdGF0ZS50cmFuc2l0aW9uc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFJlYWNoYWJsZVRhcmdldCh0cmFuc2l0aW9uLCB0b2tlbik7XG4gICAgICAgICAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGUuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgYWx0OiBjLmFsdCxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IGMuc3RhY2tcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmVhY2g7XG4gICAgaWYgKHNraXBwZWRTdG9wU3RhdGVzLmxlbmd0aCA9PT0gMCAmJiBpbnRlcm1lZGlhdGUuc2l6ZSA9PT0gMSkge1xuICAgICAgICByZWFjaCA9IGludGVybWVkaWF0ZTtcbiAgICB9XG4gICAgaWYgKHJlYWNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVhY2ggPSBuZXcgQVROQ29uZmlnU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBpbnRlcm1lZGlhdGUuZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGNsb3N1cmUoYywgcmVhY2gpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChza2lwcGVkU3RvcFN0YXRlcy5sZW5ndGggPiAwICYmICFoYXNDb25maWdJblJ1bGVTdG9wU3RhdGUocmVhY2gpKSB7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBza2lwcGVkU3RvcFN0YXRlcykge1xuICAgICAgICAgICAgcmVhY2guYWRkKGMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWFjaDtcbn1cbmZ1bmN0aW9uIGdldFJlYWNoYWJsZVRhcmdldCh0cmFuc2l0aW9uLCB0b2tlbikge1xuICAgIGlmICh0cmFuc2l0aW9uIGluc3RhbmNlb2YgQXRvbVRyYW5zaXRpb24gJiZcbiAgICAgICAgdG9rZW5NYXRjaGVyKHRva2VuLCB0cmFuc2l0aW9uLnRva2VuVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zaXRpb24udGFyZ2V0O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0VW5pcXVlQWx0KGNvbmZpZ3MsIHByZWRpY2F0ZVNldCkge1xuICAgIGxldCBhbHQ7XG4gICAgZm9yIChjb25zdCBjIG9mIGNvbmZpZ3MuZWxlbWVudHMpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZVNldC5pcyhjLmFsdCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChhbHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFsdCA9IGMuYWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWx0ICE9PSBjLmFsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFsdDtcbn1cbmZ1bmN0aW9uIG5ld0RGQVN0YXRlKGNsb3N1cmUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25maWdzOiBjbG9zdXJlLFxuICAgICAgICBlZGdlczoge30sXG4gICAgICAgIGlzQWNjZXB0U3RhdGU6IGZhbHNlLFxuICAgICAgICBwcmVkaWN0aW9uOiAtMVxuICAgIH07XG59XG5mdW5jdGlvbiBhZGRERkFFZGdlKGRmYSwgZnJvbSwgdG9rZW4sIHRvKSB7XG4gICAgdG8gPSBhZGRERkFTdGF0ZShkZmEsIHRvKTtcbiAgICBmcm9tLmVkZ2VzW3Rva2VuLnRva2VuVHlwZUlkeF0gPSB0bztcbiAgICByZXR1cm4gdG87XG59XG5mdW5jdGlvbiBhZGRERkFTdGF0ZShkZmEsIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlID09PSBERkFfRVJST1IpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAvLyBSZXBldGl0aW9ucyBoYXZlIHRoZSBzYW1lIGNvbmZpZyBzZXRcbiAgICAvLyBUaGVyZWZvcmUsIHN0b3JpbmcgdGhlIGtleSBvZiB0aGUgY29uZmlnIGluIGEgbWFwIGFsbG93cyB1cyB0byBjcmVhdGUgYSBsb29wIGluIG91ciBERkFcbiAgICBjb25zdCBtYXBLZXkgPSBzdGF0ZS5jb25maWdzLmtleTtcbiAgICBjb25zdCBleGlzdGluZyA9IGRmYS5zdGF0ZXNbbWFwS2V5XTtcbiAgICBpZiAoZXhpc3RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICAgIHN0YXRlLmNvbmZpZ3MuZmluYWxpemUoKTtcbiAgICBkZmEuc3RhdGVzW21hcEtleV0gPSBzdGF0ZTtcbiAgICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiBjb21wdXRlU3RhcnRTdGF0ZShhdG5TdGF0ZSkge1xuICAgIGNvbnN0IGNvbmZpZ3MgPSBuZXcgQVROQ29uZmlnU2V0KCk7XG4gICAgY29uc3QgbnVtYmVyT2ZUcmFuc2l0aW9ucyA9IGF0blN0YXRlLnRyYW5zaXRpb25zLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mVHJhbnNpdGlvbnM7IGkrKykge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBhdG5TdGF0ZS50cmFuc2l0aW9uc1tpXS50YXJnZXQ7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHN0YXRlOiB0YXJnZXQsXG4gICAgICAgICAgICBhbHQ6IGksXG4gICAgICAgICAgICBzdGFjazogW11cbiAgICAgICAgfTtcbiAgICAgICAgY2xvc3VyZShjb25maWcsIGNvbmZpZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlncztcbn1cbmZ1bmN0aW9uIGNsb3N1cmUoY29uZmlnLCBjb25maWdzKSB7XG4gICAgY29uc3QgcCA9IGNvbmZpZy5zdGF0ZTtcbiAgICBpZiAocC50eXBlID09PSBBVE5fUlVMRV9TVE9QKSB7XG4gICAgICAgIGlmIChjb25maWcuc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgYXRuU3RhY2sgPSBbLi4uY29uZmlnLnN0YWNrXTtcbiAgICAgICAgICAgIGNvbnN0IGZvbGxvd1N0YXRlID0gYXRuU3RhY2sucG9wKCk7XG4gICAgICAgICAgICBjb25zdCBmb2xsb3dDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgc3RhdGU6IGZvbGxvd1N0YXRlLFxuICAgICAgICAgICAgICAgIGFsdDogY29uZmlnLmFsdCxcbiAgICAgICAgICAgICAgICBzdGFjazogYXRuU3RhY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjbG9zdXJlKGZvbGxvd0NvbmZpZywgY29uZmlncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBEaXBwaW5nIGludG8gb3V0ZXIgY29udGV4dCwgc2ltcGx5IGFkZCB0aGUgY29uZmlnXG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgc3RvcCBjb21wdXRhdGlvbiBvbmNlIGV2ZXJ5IGNvbmZpZyBpcyBhdCB0aGUgcnVsZSBzdG9wIHN0YXRlXG4gICAgICAgICAgICBjb25maWdzLmFkZChjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFwLmVwc2lsb25Pbmx5VHJhbnNpdGlvbnMpIHtcbiAgICAgICAgY29uZmlncy5hZGQoY29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgdHJhbnNpdGlvbkxlbmd0aCA9IHAudHJhbnNpdGlvbnMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNpdGlvbkxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zaXRpb24gPSBwLnRyYW5zaXRpb25zW2ldO1xuICAgICAgICBjb25zdCBjID0gZ2V0RXBzaWxvblRhcmdldChjb25maWcsIHRyYW5zaXRpb24pO1xuICAgICAgICBpZiAoYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjbG9zdXJlKGMsIGNvbmZpZ3MpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RXBzaWxvblRhcmdldChjb25maWcsIHRyYW5zaXRpb24pIHtcbiAgICBpZiAodHJhbnNpdGlvbiBpbnN0YW5jZW9mIEVwc2lsb25UcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0ZTogdHJhbnNpdGlvbi50YXJnZXQsXG4gICAgICAgICAgICBhbHQ6IGNvbmZpZy5hbHQsXG4gICAgICAgICAgICBzdGFjazogY29uZmlnLnN0YWNrXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHRyYW5zaXRpb24gaW5zdGFuY2VvZiBSdWxlVHJhbnNpdGlvbikge1xuICAgICAgICBjb25zdCBzdGFjayA9IFsuLi5jb25maWcuc3RhY2ssIHRyYW5zaXRpb24uZm9sbG93U3RhdGVdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdGU6IHRyYW5zaXRpb24udGFyZ2V0LFxuICAgICAgICAgICAgYWx0OiBjb25maWcuYWx0LFxuICAgICAgICAgICAgc3RhY2tcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGhhc0NvbmZpZ0luUnVsZVN0b3BTdGF0ZShjb25maWdzKSB7XG4gICAgZm9yIChjb25zdCBjIG9mIGNvbmZpZ3MuZWxlbWVudHMpIHtcbiAgICAgICAgaWYgKGMuc3RhdGUudHlwZSA9PT0gQVROX1JVTEVfU1RPUCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gYWxsQ29uZmlnc0luUnVsZVN0b3BTdGF0ZXMoY29uZmlncykge1xuICAgIGZvciAoY29uc3QgYyBvZiBjb25maWdzLmVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChjLnN0YXRlLnR5cGUgIT09IEFUTl9SVUxFX1NUT1ApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGhhc0NvbmZsaWN0VGVybWluYXRpbmdQcmVkaWN0aW9uKGNvbmZpZ3MpIHtcbiAgICBpZiAoYWxsQ29uZmlnc0luUnVsZVN0b3BTdGF0ZXMoY29uZmlncykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGFsdFNldHMgPSBnZXRDb25mbGljdGluZ0FsdFNldHMoY29uZmlncy5lbGVtZW50cyk7XG4gICAgY29uc3QgaGV1cmlzdGljID0gaGFzQ29uZmxpY3RpbmdBbHRTZXQoYWx0U2V0cykgJiYgIWhhc1N0YXRlQXNzb2NpYXRlZFdpdGhPbmVBbHQoYWx0U2V0cyk7XG4gICAgcmV0dXJuIGhldXJpc3RpYztcbn1cbmZ1bmN0aW9uIGdldENvbmZsaWN0aW5nQWx0U2V0cyhjb25maWdzKSB7XG4gICAgY29uc3QgY29uZmlnVG9BbHRzID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgYyBvZiBjb25maWdzKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGdldEFUTkNvbmZpZ0tleShjLCBmYWxzZSk7XG4gICAgICAgIGxldCBhbHRzID0gY29uZmlnVG9BbHRzLmdldChrZXkpO1xuICAgICAgICBpZiAoYWx0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhbHRzID0ge307XG4gICAgICAgICAgICBjb25maWdUb0FsdHMuc2V0KGtleSwgYWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgYWx0c1tjLmFsdF0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnVG9BbHRzO1xufVxuZnVuY3Rpb24gaGFzQ29uZmxpY3RpbmdBbHRTZXQoYWx0U2V0cykge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgQXJyYXkuZnJvbShhbHRTZXRzLnZhbHVlcygpKSkge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGhhc1N0YXRlQXNzb2NpYXRlZFdpdGhPbmVBbHQoYWx0U2V0cykge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgQXJyYXkuZnJvbShhbHRTZXRzLnZhbHVlcygpKSkge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWxsLXN0YXItbG9va2FoZWFkLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain-allstar/lib/all-star-lookahead.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain-allstar/lib/atn.js":
/*!****************************************************!*\
  !*** ./node_modules/chevrotain-allstar/lib/atn.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ATN_BASIC: () => (/* binding */ ATN_BASIC),\n/* harmony export */   ATN_BLOCK_END: () => (/* binding */ ATN_BLOCK_END),\n/* harmony export */   ATN_INVALID_TYPE: () => (/* binding */ ATN_INVALID_TYPE),\n/* harmony export */   ATN_LOOP_END: () => (/* binding */ ATN_LOOP_END),\n/* harmony export */   ATN_PLUS_BLOCK_START: () => (/* binding */ ATN_PLUS_BLOCK_START),\n/* harmony export */   ATN_PLUS_LOOP_BACK: () => (/* binding */ ATN_PLUS_LOOP_BACK),\n/* harmony export */   ATN_RULE_START: () => (/* binding */ ATN_RULE_START),\n/* harmony export */   ATN_RULE_STOP: () => (/* binding */ ATN_RULE_STOP),\n/* harmony export */   ATN_STAR_BLOCK_START: () => (/* binding */ ATN_STAR_BLOCK_START),\n/* harmony export */   ATN_STAR_LOOP_BACK: () => (/* binding */ ATN_STAR_LOOP_BACK),\n/* harmony export */   ATN_STAR_LOOP_ENTRY: () => (/* binding */ ATN_STAR_LOOP_ENTRY),\n/* harmony export */   ATN_TOKEN_START: () => (/* binding */ ATN_TOKEN_START),\n/* harmony export */   AbstractTransition: () => (/* binding */ AbstractTransition),\n/* harmony export */   AtomTransition: () => (/* binding */ AtomTransition),\n/* harmony export */   EpsilonTransition: () => (/* binding */ EpsilonTransition),\n/* harmony export */   RuleTransition: () => (/* binding */ RuleTransition),\n/* harmony export */   buildATNKey: () => (/* binding */ buildATNKey),\n/* harmony export */   createATN: () => (/* binding */ createATN)\n/* harmony export */ });\n/* harmony import */ var lodash_es_map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es/map.js */ \"(ssr)/./node_modules/lodash-es/map.js\");\n/* harmony import */ var lodash_es_filter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es/filter.js */ \"(ssr)/./node_modules/lodash-es/filter.js\");\n/* harmony import */ var chevrotain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chevrotain */ \"(ssr)/./node_modules/chevrotain/lib/src/api.js\");\n/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\nfunction buildATNKey(rule, type, occurrence) {\n    return `${rule.name}_${type}_${occurrence}`;\n}\nconst ATN_INVALID_TYPE = 0;\nconst ATN_BASIC = 1;\nconst ATN_RULE_START = 2;\nconst ATN_PLUS_BLOCK_START = 4;\nconst ATN_STAR_BLOCK_START = 5;\n// Currently unused as the ATN is not used for lexing\nconst ATN_TOKEN_START = 6;\nconst ATN_RULE_STOP = 7;\nconst ATN_BLOCK_END = 8;\nconst ATN_STAR_LOOP_BACK = 9;\nconst ATN_STAR_LOOP_ENTRY = 10;\nconst ATN_PLUS_LOOP_BACK = 11;\nconst ATN_LOOP_END = 12;\nclass AbstractTransition {\n    constructor(target) {\n        this.target = target;\n    }\n    isEpsilon() {\n        return false;\n    }\n}\nclass AtomTransition extends AbstractTransition {\n    constructor(target, tokenType) {\n        super(target);\n        this.tokenType = tokenType;\n    }\n}\nclass EpsilonTransition extends AbstractTransition {\n    constructor(target) {\n        super(target);\n    }\n    isEpsilon() {\n        return true;\n    }\n}\nclass RuleTransition extends AbstractTransition {\n    constructor(ruleStart, rule, followState) {\n        super(ruleStart);\n        this.rule = rule;\n        this.followState = followState;\n    }\n    isEpsilon() {\n        return true;\n    }\n}\nfunction createATN(rules) {\n    const atn = {\n        decisionMap: {},\n        decisionStates: [],\n        ruleToStartState: new Map(),\n        ruleToStopState: new Map(),\n        states: []\n    };\n    createRuleStartAndStopATNStates(atn, rules);\n    const ruleLength = rules.length;\n    for (let i = 0; i < ruleLength; i++) {\n        const rule = rules[i];\n        const ruleBlock = block(atn, rule, rule);\n        if (ruleBlock === undefined) {\n            continue;\n        }\n        buildRuleHandle(atn, rule, ruleBlock);\n    }\n    return atn;\n}\nfunction createRuleStartAndStopATNStates(atn, rules) {\n    const ruleLength = rules.length;\n    for (let i = 0; i < ruleLength; i++) {\n        const rule = rules[i];\n        const start = newState(atn, rule, undefined, {\n            type: ATN_RULE_START\n        });\n        const stop = newState(atn, rule, undefined, {\n            type: ATN_RULE_STOP\n        });\n        start.stop = stop;\n        atn.ruleToStartState.set(rule, start);\n        atn.ruleToStopState.set(rule, stop);\n    }\n}\nfunction atom(atn, rule, production) {\n    if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.Terminal) {\n        return tokenRef(atn, rule, production.terminalType, production);\n    }\n    else if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.NonTerminal) {\n        return ruleRef(atn, rule, production);\n    }\n    else if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.Alternation) {\n        return alternation(atn, rule, production);\n    }\n    else if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.Option) {\n        return option(atn, rule, production);\n    }\n    else if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.Repetition) {\n        return repetition(atn, rule, production);\n    }\n    else if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.RepetitionWithSeparator) {\n        return repetitionSep(atn, rule, production);\n    }\n    else if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatory) {\n        return repetitionMandatory(atn, rule, production);\n    }\n    else if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatoryWithSeparator) {\n        return repetitionMandatorySep(atn, rule, production);\n    }\n    else {\n        return block(atn, rule, production);\n    }\n}\nfunction repetition(atn, rule, repetition) {\n    const starState = newState(atn, rule, repetition, {\n        type: ATN_STAR_BLOCK_START\n    });\n    defineDecisionState(atn, starState);\n    const handle = makeAlts(atn, rule, starState, repetition, block(atn, rule, repetition));\n    return star(atn, rule, repetition, handle);\n}\nfunction repetitionSep(atn, rule, repetition) {\n    const starState = newState(atn, rule, repetition, {\n        type: ATN_STAR_BLOCK_START\n    });\n    defineDecisionState(atn, starState);\n    const handle = makeAlts(atn, rule, starState, repetition, block(atn, rule, repetition));\n    const sep = tokenRef(atn, rule, repetition.separator, repetition);\n    return star(atn, rule, repetition, handle, sep);\n}\nfunction repetitionMandatory(atn, rule, repetition) {\n    const plusState = newState(atn, rule, repetition, {\n        type: ATN_PLUS_BLOCK_START\n    });\n    defineDecisionState(atn, plusState);\n    const handle = makeAlts(atn, rule, plusState, repetition, block(atn, rule, repetition));\n    return plus(atn, rule, repetition, handle);\n}\nfunction repetitionMandatorySep(atn, rule, repetition) {\n    const plusState = newState(atn, rule, repetition, {\n        type: ATN_PLUS_BLOCK_START\n    });\n    defineDecisionState(atn, plusState);\n    const handle = makeAlts(atn, rule, plusState, repetition, block(atn, rule, repetition));\n    const sep = tokenRef(atn, rule, repetition.separator, repetition);\n    return plus(atn, rule, repetition, handle, sep);\n}\nfunction alternation(atn, rule, alternation) {\n    const start = newState(atn, rule, alternation, {\n        type: ATN_BASIC\n    });\n    defineDecisionState(atn, start);\n    const alts = (0,lodash_es_map_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(alternation.definition, (e) => atom(atn, rule, e));\n    const handle = makeAlts(atn, rule, start, alternation, ...alts);\n    return handle;\n}\nfunction option(atn, rule, option) {\n    const start = newState(atn, rule, option, {\n        type: ATN_BASIC\n    });\n    defineDecisionState(atn, start);\n    const handle = makeAlts(atn, rule, start, option, block(atn, rule, option));\n    return optional(atn, rule, option, handle);\n}\nfunction block(atn, rule, block) {\n    const handles = (0,lodash_es_filter_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])((0,lodash_es_map_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(block.definition, (e) => atom(atn, rule, e)), (e) => e !== undefined);\n    if (handles.length === 1) {\n        return handles[0];\n    }\n    else if (handles.length === 0) {\n        return undefined;\n    }\n    else {\n        return makeBlock(atn, handles);\n    }\n}\nfunction plus(atn, rule, plus, handle, sep) {\n    const blkStart = handle.left;\n    const blkEnd = handle.right;\n    const loop = newState(atn, rule, plus, {\n        type: ATN_PLUS_LOOP_BACK\n    });\n    defineDecisionState(atn, loop);\n    const end = newState(atn, rule, plus, {\n        type: ATN_LOOP_END\n    });\n    blkStart.loopback = loop;\n    end.loopback = loop;\n    atn.decisionMap[buildATNKey(rule, sep ? 'RepetitionMandatoryWithSeparator' : 'RepetitionMandatory', plus.idx)] = loop;\n    epsilon(blkEnd, loop); // block can see loop back\n    // Depending on whether we have a separator we put the exit transition at index 1 or 0\n    // This influences the chosen option in the lookahead DFA\n    if (sep === undefined) {\n        epsilon(loop, blkStart); // loop back to start\n        epsilon(loop, end); // exit\n    }\n    else {\n        epsilon(loop, end); // exit\n        // loop back to start with separator\n        epsilon(loop, sep.left);\n        epsilon(sep.right, blkStart);\n    }\n    return {\n        left: blkStart,\n        right: end\n    };\n}\nfunction star(atn, rule, star, handle, sep) {\n    const start = handle.left;\n    const end = handle.right;\n    const entry = newState(atn, rule, star, {\n        type: ATN_STAR_LOOP_ENTRY\n    });\n    defineDecisionState(atn, entry);\n    const loopEnd = newState(atn, rule, star, {\n        type: ATN_LOOP_END\n    });\n    const loop = newState(atn, rule, star, {\n        type: ATN_STAR_LOOP_BACK\n    });\n    entry.loopback = loop;\n    loopEnd.loopback = loop;\n    epsilon(entry, start); // loop enter edge (alt 2)\n    epsilon(entry, loopEnd); // bypass loop edge (alt 1)\n    epsilon(end, loop); // block end hits loop back\n    if (sep !== undefined) {\n        epsilon(loop, loopEnd); // end loop\n        // loop back to start of handle using separator\n        epsilon(loop, sep.left);\n        epsilon(sep.right, start);\n    }\n    else {\n        epsilon(loop, entry); // loop back to entry/exit decision\n    }\n    atn.decisionMap[buildATNKey(rule, sep ? 'RepetitionWithSeparator' : 'Repetition', star.idx)] = entry;\n    return {\n        left: entry,\n        right: loopEnd\n    };\n}\nfunction optional(atn, rule, optional, handle) {\n    const start = handle.left;\n    const end = handle.right;\n    epsilon(start, end);\n    atn.decisionMap[buildATNKey(rule, 'Option', optional.idx)] = start;\n    return handle;\n}\nfunction defineDecisionState(atn, state) {\n    atn.decisionStates.push(state);\n    state.decision = atn.decisionStates.length - 1;\n    return state.decision;\n}\nfunction makeAlts(atn, rule, start, production, ...alts) {\n    const end = newState(atn, rule, production, {\n        type: ATN_BLOCK_END,\n        start\n    });\n    start.end = end;\n    for (const alt of alts) {\n        if (alt !== undefined) {\n            // hook alts up to decision block\n            epsilon(start, alt.left);\n            epsilon(alt.right, end);\n        }\n        else {\n            epsilon(start, end);\n        }\n    }\n    const handle = {\n        left: start,\n        right: end\n    };\n    atn.decisionMap[buildATNKey(rule, getProdType(production), production.idx)] = start;\n    return handle;\n}\nfunction getProdType(production) {\n    if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.Alternation) {\n        return 'Alternation';\n    }\n    else if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.Option) {\n        return 'Option';\n    }\n    else if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.Repetition) {\n        return 'Repetition';\n    }\n    else if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.RepetitionWithSeparator) {\n        return 'RepetitionWithSeparator';\n    }\n    else if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatory) {\n        return 'RepetitionMandatory';\n    }\n    else if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatoryWithSeparator) {\n        return 'RepetitionMandatoryWithSeparator';\n    }\n    else {\n        throw new Error('Invalid production type encountered');\n    }\n}\nfunction makeBlock(atn, alts) {\n    const altsLength = alts.length;\n    for (let i = 0; i < altsLength - 1; i++) {\n        const handle = alts[i];\n        let transition;\n        if (handle.left.transitions.length === 1) {\n            transition = handle.left.transitions[0];\n        }\n        const isRuleTransition = transition instanceof RuleTransition;\n        const ruleTransition = transition;\n        const next = alts[i + 1].left;\n        if (handle.left.type === ATN_BASIC &&\n            handle.right.type === ATN_BASIC &&\n            transition !== undefined &&\n            ((isRuleTransition && ruleTransition.followState === handle.right) ||\n                transition.target === handle.right)) {\n            // we can avoid epsilon edge to next element\n            if (isRuleTransition) {\n                ruleTransition.followState = next;\n            }\n            else {\n                transition.target = next;\n            }\n            removeState(atn, handle.right); // we skipped over this state\n        }\n        else {\n            // need epsilon if previous block's right end node is complex\n            epsilon(handle.right, next);\n        }\n    }\n    const first = alts[0];\n    const last = alts[altsLength - 1];\n    return {\n        left: first.left,\n        right: last.right\n    };\n}\nfunction tokenRef(atn, rule, tokenType, production) {\n    const left = newState(atn, rule, production, {\n        type: ATN_BASIC\n    });\n    const right = newState(atn, rule, production, {\n        type: ATN_BASIC\n    });\n    addTransition(left, new AtomTransition(right, tokenType));\n    return {\n        left,\n        right\n    };\n}\nfunction ruleRef(atn, currentRule, nonTerminal) {\n    const rule = nonTerminal.referencedRule;\n    const start = atn.ruleToStartState.get(rule);\n    const left = newState(atn, currentRule, nonTerminal, {\n        type: ATN_BASIC\n    });\n    const right = newState(atn, currentRule, nonTerminal, {\n        type: ATN_BASIC\n    });\n    const call = new RuleTransition(start, rule, right);\n    addTransition(left, call);\n    return {\n        left,\n        right\n    };\n}\nfunction buildRuleHandle(atn, rule, block) {\n    const start = atn.ruleToStartState.get(rule);\n    epsilon(start, block.left);\n    const stop = atn.ruleToStopState.get(rule);\n    epsilon(block.right, stop);\n    const handle = {\n        left: start,\n        right: stop\n    };\n    return handle;\n}\nfunction epsilon(a, b) {\n    const transition = new EpsilonTransition(b);\n    addTransition(a, transition);\n}\nfunction newState(atn, rule, production, partial) {\n    const t = Object.assign({ atn,\n        production, epsilonOnlyTransitions: false, rule, transitions: [], nextTokenWithinRule: [], stateNumber: atn.states.length }, partial);\n    atn.states.push(t);\n    return t;\n}\nfunction addTransition(state, transition) {\n    // A single ATN state can only contain epsilon transitions or non-epsilon transitions\n    // Because they are never mixed, only setting the property for the first transition is fine\n    if (state.transitions.length === 0) {\n        state.epsilonOnlyTransitions = transition.isEpsilon();\n    }\n    state.transitions.push(transition);\n}\nfunction removeState(atn, state) {\n    atn.states.splice(atn.states.indexOf(state), 1);\n}\n//# sourceMappingURL=atn.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi1hbGxzdGFyL2xpYi9hdG4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNtQztBQUNNO0FBQzJIO0FBQzdKO0FBQ1AsY0FBYyxVQUFVLEdBQUcsS0FBSyxHQUFHLFdBQVc7QUFDOUM7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0RBQVE7QUFDdEM7QUFDQTtBQUNBLG1DQUFtQyxtREFBVztBQUM5QztBQUNBO0FBQ0EsbUNBQW1DLG1EQUFXO0FBQzlDO0FBQ0E7QUFDQSxtQ0FBbUMsOENBQU07QUFDekM7QUFDQTtBQUNBLG1DQUFtQyxrREFBVTtBQUM3QztBQUNBO0FBQ0EsbUNBQW1DLCtEQUF1QjtBQUMxRDtBQUNBO0FBQ0EsbUNBQW1DLDJEQUFtQjtBQUN0RDtBQUNBO0FBQ0EsbUNBQW1DLHdFQUFnQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUJBQWlCLDREQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtEQUFNLENBQUMsNERBQUc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiw2QkFBNkI7QUFDN0Isd0JBQXdCO0FBQ3hCO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtREFBVztBQUN6QztBQUNBO0FBQ0EsbUNBQW1DLDhDQUFNO0FBQ3pDO0FBQ0E7QUFDQSxtQ0FBbUMsa0RBQVU7QUFDN0M7QUFDQTtBQUNBLG1DQUFtQywrREFBdUI7QUFDMUQ7QUFDQTtBQUNBLG1DQUFtQywyREFBbUI7QUFDdEQ7QUFDQTtBQUNBLG1DQUFtQyx3RUFBZ0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLG1JQUFtSTtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9uYWthaWtlbnRvL25vdGUtYWdlbnQvbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4tYWxsc3Rhci9saWIvYXRuLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIyIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCBtYXAgZnJvbSBcImxvZGFzaC1lcy9tYXAuanNcIjtcbmltcG9ydCBmaWx0ZXIgZnJvbSBcImxvZGFzaC1lcy9maWx0ZXIuanNcIjtcbmltcG9ydCB7IEFsdGVybmF0aW9uLCBOb25UZXJtaW5hbCwgT3B0aW9uLCBSZXBldGl0aW9uTWFuZGF0b3J5LCBSZXBldGl0aW9uLCBUZXJtaW5hbCwgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IsIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yIH0gZnJvbSBcImNoZXZyb3RhaW5cIjtcbmV4cG9ydCBmdW5jdGlvbiBidWlsZEFUTktleShydWxlLCB0eXBlLCBvY2N1cnJlbmNlKSB7XG4gICAgcmV0dXJuIGAke3J1bGUubmFtZX1fJHt0eXBlfV8ke29jY3VycmVuY2V9YDtcbn1cbmV4cG9ydCBjb25zdCBBVE5fSU5WQUxJRF9UWVBFID0gMDtcbmV4cG9ydCBjb25zdCBBVE5fQkFTSUMgPSAxO1xuZXhwb3J0IGNvbnN0IEFUTl9SVUxFX1NUQVJUID0gMjtcbmV4cG9ydCBjb25zdCBBVE5fUExVU19CTE9DS19TVEFSVCA9IDQ7XG5leHBvcnQgY29uc3QgQVROX1NUQVJfQkxPQ0tfU1RBUlQgPSA1O1xuLy8gQ3VycmVudGx5IHVudXNlZCBhcyB0aGUgQVROIGlzIG5vdCB1c2VkIGZvciBsZXhpbmdcbmV4cG9ydCBjb25zdCBBVE5fVE9LRU5fU1RBUlQgPSA2O1xuZXhwb3J0IGNvbnN0IEFUTl9SVUxFX1NUT1AgPSA3O1xuZXhwb3J0IGNvbnN0IEFUTl9CTE9DS19FTkQgPSA4O1xuZXhwb3J0IGNvbnN0IEFUTl9TVEFSX0xPT1BfQkFDSyA9IDk7XG5leHBvcnQgY29uc3QgQVROX1NUQVJfTE9PUF9FTlRSWSA9IDEwO1xuZXhwb3J0IGNvbnN0IEFUTl9QTFVTX0xPT1BfQkFDSyA9IDExO1xuZXhwb3J0IGNvbnN0IEFUTl9MT09QX0VORCA9IDEyO1xuZXhwb3J0IGNsYXNzIEFic3RyYWN0VHJhbnNpdGlvbiB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIH1cbiAgICBpc0Vwc2lsb24oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQXRvbVRyYW5zaXRpb24gZXh0ZW5kcyBBYnN0cmFjdFRyYW5zaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgdG9rZW5UeXBlKSB7XG4gICAgICAgIHN1cGVyKHRhcmdldCk7XG4gICAgICAgIHRoaXMudG9rZW5UeXBlID0gdG9rZW5UeXBlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBFcHNpbG9uVHJhbnNpdGlvbiBleHRlbmRzIEFic3RyYWN0VHJhbnNpdGlvbiB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XG4gICAgICAgIHN1cGVyKHRhcmdldCk7XG4gICAgfVxuICAgIGlzRXBzaWxvbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFJ1bGVUcmFuc2l0aW9uIGV4dGVuZHMgQWJzdHJhY3RUcmFuc2l0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihydWxlU3RhcnQsIHJ1bGUsIGZvbGxvd1N0YXRlKSB7XG4gICAgICAgIHN1cGVyKHJ1bGVTdGFydCk7XG4gICAgICAgIHRoaXMucnVsZSA9IHJ1bGU7XG4gICAgICAgIHRoaXMuZm9sbG93U3RhdGUgPSBmb2xsb3dTdGF0ZTtcbiAgICB9XG4gICAgaXNFcHNpbG9uKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQVROKHJ1bGVzKSB7XG4gICAgY29uc3QgYXRuID0ge1xuICAgICAgICBkZWNpc2lvbk1hcDoge30sXG4gICAgICAgIGRlY2lzaW9uU3RhdGVzOiBbXSxcbiAgICAgICAgcnVsZVRvU3RhcnRTdGF0ZTogbmV3IE1hcCgpLFxuICAgICAgICBydWxlVG9TdG9wU3RhdGU6IG5ldyBNYXAoKSxcbiAgICAgICAgc3RhdGVzOiBbXVxuICAgIH07XG4gICAgY3JlYXRlUnVsZVN0YXJ0QW5kU3RvcEFUTlN0YXRlcyhhdG4sIHJ1bGVzKTtcbiAgICBjb25zdCBydWxlTGVuZ3RoID0gcnVsZXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcnVsZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSBydWxlc1tpXTtcbiAgICAgICAgY29uc3QgcnVsZUJsb2NrID0gYmxvY2soYXRuLCBydWxlLCBydWxlKTtcbiAgICAgICAgaWYgKHJ1bGVCbG9jayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBidWlsZFJ1bGVIYW5kbGUoYXRuLCBydWxlLCBydWxlQmxvY2spO1xuICAgIH1cbiAgICByZXR1cm4gYXRuO1xufVxuZnVuY3Rpb24gY3JlYXRlUnVsZVN0YXJ0QW5kU3RvcEFUTlN0YXRlcyhhdG4sIHJ1bGVzKSB7XG4gICAgY29uc3QgcnVsZUxlbmd0aCA9IHJ1bGVzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJ1bGVMZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBydWxlID0gcnVsZXNbaV07XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbmV3U3RhdGUoYXRuLCBydWxlLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgIHR5cGU6IEFUTl9SVUxFX1NUQVJUXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzdG9wID0gbmV3U3RhdGUoYXRuLCBydWxlLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgIHR5cGU6IEFUTl9SVUxFX1NUT1BcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXJ0LnN0b3AgPSBzdG9wO1xuICAgICAgICBhdG4ucnVsZVRvU3RhcnRTdGF0ZS5zZXQocnVsZSwgc3RhcnQpO1xuICAgICAgICBhdG4ucnVsZVRvU3RvcFN0YXRlLnNldChydWxlLCBzdG9wKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhdG9tKGF0biwgcnVsZSwgcHJvZHVjdGlvbikge1xuICAgIGlmIChwcm9kdWN0aW9uIGluc3RhbmNlb2YgVGVybWluYWwpIHtcbiAgICAgICAgcmV0dXJuIHRva2VuUmVmKGF0biwgcnVsZSwgcHJvZHVjdGlvbi50ZXJtaW5hbFR5cGUsIHByb2R1Y3Rpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kdWN0aW9uIGluc3RhbmNlb2YgTm9uVGVybWluYWwpIHtcbiAgICAgICAgcmV0dXJuIHJ1bGVSZWYoYXRuLCBydWxlLCBwcm9kdWN0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZHVjdGlvbiBpbnN0YW5jZW9mIEFsdGVybmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBhbHRlcm5hdGlvbihhdG4sIHJ1bGUsIHByb2R1Y3Rpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kdWN0aW9uIGluc3RhbmNlb2YgT3B0aW9uKSB7XG4gICAgICAgIHJldHVybiBvcHRpb24oYXRuLCBydWxlLCBwcm9kdWN0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZHVjdGlvbiBpbnN0YW5jZW9mIFJlcGV0aXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHJlcGV0aXRpb24oYXRuLCBydWxlLCBwcm9kdWN0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZHVjdGlvbiBpbnN0YW5jZW9mIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiByZXBldGl0aW9uU2VwKGF0biwgcnVsZSwgcHJvZHVjdGlvbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2R1Y3Rpb24gaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5KSB7XG4gICAgICAgIHJldHVybiByZXBldGl0aW9uTWFuZGF0b3J5KGF0biwgcnVsZSwgcHJvZHVjdGlvbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2R1Y3Rpb24gaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gcmVwZXRpdGlvbk1hbmRhdG9yeVNlcChhdG4sIHJ1bGUsIHByb2R1Y3Rpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrKGF0biwgcnVsZSwgcHJvZHVjdGlvbik7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVwZXRpdGlvbihhdG4sIHJ1bGUsIHJlcGV0aXRpb24pIHtcbiAgICBjb25zdCBzdGFyU3RhdGUgPSBuZXdTdGF0ZShhdG4sIHJ1bGUsIHJlcGV0aXRpb24sIHtcbiAgICAgICAgdHlwZTogQVROX1NUQVJfQkxPQ0tfU1RBUlRcbiAgICB9KTtcbiAgICBkZWZpbmVEZWNpc2lvblN0YXRlKGF0biwgc3RhclN0YXRlKTtcbiAgICBjb25zdCBoYW5kbGUgPSBtYWtlQWx0cyhhdG4sIHJ1bGUsIHN0YXJTdGF0ZSwgcmVwZXRpdGlvbiwgYmxvY2soYXRuLCBydWxlLCByZXBldGl0aW9uKSk7XG4gICAgcmV0dXJuIHN0YXIoYXRuLCBydWxlLCByZXBldGl0aW9uLCBoYW5kbGUpO1xufVxuZnVuY3Rpb24gcmVwZXRpdGlvblNlcChhdG4sIHJ1bGUsIHJlcGV0aXRpb24pIHtcbiAgICBjb25zdCBzdGFyU3RhdGUgPSBuZXdTdGF0ZShhdG4sIHJ1bGUsIHJlcGV0aXRpb24sIHtcbiAgICAgICAgdHlwZTogQVROX1NUQVJfQkxPQ0tfU1RBUlRcbiAgICB9KTtcbiAgICBkZWZpbmVEZWNpc2lvblN0YXRlKGF0biwgc3RhclN0YXRlKTtcbiAgICBjb25zdCBoYW5kbGUgPSBtYWtlQWx0cyhhdG4sIHJ1bGUsIHN0YXJTdGF0ZSwgcmVwZXRpdGlvbiwgYmxvY2soYXRuLCBydWxlLCByZXBldGl0aW9uKSk7XG4gICAgY29uc3Qgc2VwID0gdG9rZW5SZWYoYXRuLCBydWxlLCByZXBldGl0aW9uLnNlcGFyYXRvciwgcmVwZXRpdGlvbik7XG4gICAgcmV0dXJuIHN0YXIoYXRuLCBydWxlLCByZXBldGl0aW9uLCBoYW5kbGUsIHNlcCk7XG59XG5mdW5jdGlvbiByZXBldGl0aW9uTWFuZGF0b3J5KGF0biwgcnVsZSwgcmVwZXRpdGlvbikge1xuICAgIGNvbnN0IHBsdXNTdGF0ZSA9IG5ld1N0YXRlKGF0biwgcnVsZSwgcmVwZXRpdGlvbiwge1xuICAgICAgICB0eXBlOiBBVE5fUExVU19CTE9DS19TVEFSVFxuICAgIH0pO1xuICAgIGRlZmluZURlY2lzaW9uU3RhdGUoYXRuLCBwbHVzU3RhdGUpO1xuICAgIGNvbnN0IGhhbmRsZSA9IG1ha2VBbHRzKGF0biwgcnVsZSwgcGx1c1N0YXRlLCByZXBldGl0aW9uLCBibG9jayhhdG4sIHJ1bGUsIHJlcGV0aXRpb24pKTtcbiAgICByZXR1cm4gcGx1cyhhdG4sIHJ1bGUsIHJlcGV0aXRpb24sIGhhbmRsZSk7XG59XG5mdW5jdGlvbiByZXBldGl0aW9uTWFuZGF0b3J5U2VwKGF0biwgcnVsZSwgcmVwZXRpdGlvbikge1xuICAgIGNvbnN0IHBsdXNTdGF0ZSA9IG5ld1N0YXRlKGF0biwgcnVsZSwgcmVwZXRpdGlvbiwge1xuICAgICAgICB0eXBlOiBBVE5fUExVU19CTE9DS19TVEFSVFxuICAgIH0pO1xuICAgIGRlZmluZURlY2lzaW9uU3RhdGUoYXRuLCBwbHVzU3RhdGUpO1xuICAgIGNvbnN0IGhhbmRsZSA9IG1ha2VBbHRzKGF0biwgcnVsZSwgcGx1c1N0YXRlLCByZXBldGl0aW9uLCBibG9jayhhdG4sIHJ1bGUsIHJlcGV0aXRpb24pKTtcbiAgICBjb25zdCBzZXAgPSB0b2tlblJlZihhdG4sIHJ1bGUsIHJlcGV0aXRpb24uc2VwYXJhdG9yLCByZXBldGl0aW9uKTtcbiAgICByZXR1cm4gcGx1cyhhdG4sIHJ1bGUsIHJlcGV0aXRpb24sIGhhbmRsZSwgc2VwKTtcbn1cbmZ1bmN0aW9uIGFsdGVybmF0aW9uKGF0biwgcnVsZSwgYWx0ZXJuYXRpb24pIHtcbiAgICBjb25zdCBzdGFydCA9IG5ld1N0YXRlKGF0biwgcnVsZSwgYWx0ZXJuYXRpb24sIHtcbiAgICAgICAgdHlwZTogQVROX0JBU0lDXG4gICAgfSk7XG4gICAgZGVmaW5lRGVjaXNpb25TdGF0ZShhdG4sIHN0YXJ0KTtcbiAgICBjb25zdCBhbHRzID0gbWFwKGFsdGVybmF0aW9uLmRlZmluaXRpb24sIChlKSA9PiBhdG9tKGF0biwgcnVsZSwgZSkpO1xuICAgIGNvbnN0IGhhbmRsZSA9IG1ha2VBbHRzKGF0biwgcnVsZSwgc3RhcnQsIGFsdGVybmF0aW9uLCAuLi5hbHRzKTtcbiAgICByZXR1cm4gaGFuZGxlO1xufVxuZnVuY3Rpb24gb3B0aW9uKGF0biwgcnVsZSwgb3B0aW9uKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBuZXdTdGF0ZShhdG4sIHJ1bGUsIG9wdGlvbiwge1xuICAgICAgICB0eXBlOiBBVE5fQkFTSUNcbiAgICB9KTtcbiAgICBkZWZpbmVEZWNpc2lvblN0YXRlKGF0biwgc3RhcnQpO1xuICAgIGNvbnN0IGhhbmRsZSA9IG1ha2VBbHRzKGF0biwgcnVsZSwgc3RhcnQsIG9wdGlvbiwgYmxvY2soYXRuLCBydWxlLCBvcHRpb24pKTtcbiAgICByZXR1cm4gb3B0aW9uYWwoYXRuLCBydWxlLCBvcHRpb24sIGhhbmRsZSk7XG59XG5mdW5jdGlvbiBibG9jayhhdG4sIHJ1bGUsIGJsb2NrKSB7XG4gICAgY29uc3QgaGFuZGxlcyA9IGZpbHRlcihtYXAoYmxvY2suZGVmaW5pdGlvbiwgKGUpID0+IGF0b20oYXRuLCBydWxlLCBlKSksIChlKSA9PiBlICE9PSB1bmRlZmluZWQpO1xuICAgIGlmIChoYW5kbGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gaGFuZGxlc1swXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFuZGxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBtYWtlQmxvY2soYXRuLCBoYW5kbGVzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwbHVzKGF0biwgcnVsZSwgcGx1cywgaGFuZGxlLCBzZXApIHtcbiAgICBjb25zdCBibGtTdGFydCA9IGhhbmRsZS5sZWZ0O1xuICAgIGNvbnN0IGJsa0VuZCA9IGhhbmRsZS5yaWdodDtcbiAgICBjb25zdCBsb29wID0gbmV3U3RhdGUoYXRuLCBydWxlLCBwbHVzLCB7XG4gICAgICAgIHR5cGU6IEFUTl9QTFVTX0xPT1BfQkFDS1xuICAgIH0pO1xuICAgIGRlZmluZURlY2lzaW9uU3RhdGUoYXRuLCBsb29wKTtcbiAgICBjb25zdCBlbmQgPSBuZXdTdGF0ZShhdG4sIHJ1bGUsIHBsdXMsIHtcbiAgICAgICAgdHlwZTogQVROX0xPT1BfRU5EXG4gICAgfSk7XG4gICAgYmxrU3RhcnQubG9vcGJhY2sgPSBsb29wO1xuICAgIGVuZC5sb29wYmFjayA9IGxvb3A7XG4gICAgYXRuLmRlY2lzaW9uTWFwW2J1aWxkQVROS2V5KHJ1bGUsIHNlcCA/ICdSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcicgOiAnUmVwZXRpdGlvbk1hbmRhdG9yeScsIHBsdXMuaWR4KV0gPSBsb29wO1xuICAgIGVwc2lsb24oYmxrRW5kLCBsb29wKTsgLy8gYmxvY2sgY2FuIHNlZSBsb29wIGJhY2tcbiAgICAvLyBEZXBlbmRpbmcgb24gd2hldGhlciB3ZSBoYXZlIGEgc2VwYXJhdG9yIHdlIHB1dCB0aGUgZXhpdCB0cmFuc2l0aW9uIGF0IGluZGV4IDEgb3IgMFxuICAgIC8vIFRoaXMgaW5mbHVlbmNlcyB0aGUgY2hvc2VuIG9wdGlvbiBpbiB0aGUgbG9va2FoZWFkIERGQVxuICAgIGlmIChzZXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlcHNpbG9uKGxvb3AsIGJsa1N0YXJ0KTsgLy8gbG9vcCBiYWNrIHRvIHN0YXJ0XG4gICAgICAgIGVwc2lsb24obG9vcCwgZW5kKTsgLy8gZXhpdFxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZXBzaWxvbihsb29wLCBlbmQpOyAvLyBleGl0XG4gICAgICAgIC8vIGxvb3AgYmFjayB0byBzdGFydCB3aXRoIHNlcGFyYXRvclxuICAgICAgICBlcHNpbG9uKGxvb3AsIHNlcC5sZWZ0KTtcbiAgICAgICAgZXBzaWxvbihzZXAucmlnaHQsIGJsa1N0YXJ0KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogYmxrU3RhcnQsXG4gICAgICAgIHJpZ2h0OiBlbmRcbiAgICB9O1xufVxuZnVuY3Rpb24gc3RhcihhdG4sIHJ1bGUsIHN0YXIsIGhhbmRsZSwgc2VwKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBoYW5kbGUubGVmdDtcbiAgICBjb25zdCBlbmQgPSBoYW5kbGUucmlnaHQ7XG4gICAgY29uc3QgZW50cnkgPSBuZXdTdGF0ZShhdG4sIHJ1bGUsIHN0YXIsIHtcbiAgICAgICAgdHlwZTogQVROX1NUQVJfTE9PUF9FTlRSWVxuICAgIH0pO1xuICAgIGRlZmluZURlY2lzaW9uU3RhdGUoYXRuLCBlbnRyeSk7XG4gICAgY29uc3QgbG9vcEVuZCA9IG5ld1N0YXRlKGF0biwgcnVsZSwgc3Rhciwge1xuICAgICAgICB0eXBlOiBBVE5fTE9PUF9FTkRcbiAgICB9KTtcbiAgICBjb25zdCBsb29wID0gbmV3U3RhdGUoYXRuLCBydWxlLCBzdGFyLCB7XG4gICAgICAgIHR5cGU6IEFUTl9TVEFSX0xPT1BfQkFDS1xuICAgIH0pO1xuICAgIGVudHJ5Lmxvb3BiYWNrID0gbG9vcDtcbiAgICBsb29wRW5kLmxvb3BiYWNrID0gbG9vcDtcbiAgICBlcHNpbG9uKGVudHJ5LCBzdGFydCk7IC8vIGxvb3AgZW50ZXIgZWRnZSAoYWx0IDIpXG4gICAgZXBzaWxvbihlbnRyeSwgbG9vcEVuZCk7IC8vIGJ5cGFzcyBsb29wIGVkZ2UgKGFsdCAxKVxuICAgIGVwc2lsb24oZW5kLCBsb29wKTsgLy8gYmxvY2sgZW5kIGhpdHMgbG9vcCBiYWNrXG4gICAgaWYgKHNlcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVwc2lsb24obG9vcCwgbG9vcEVuZCk7IC8vIGVuZCBsb29wXG4gICAgICAgIC8vIGxvb3AgYmFjayB0byBzdGFydCBvZiBoYW5kbGUgdXNpbmcgc2VwYXJhdG9yXG4gICAgICAgIGVwc2lsb24obG9vcCwgc2VwLmxlZnQpO1xuICAgICAgICBlcHNpbG9uKHNlcC5yaWdodCwgc3RhcnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZXBzaWxvbihsb29wLCBlbnRyeSk7IC8vIGxvb3AgYmFjayB0byBlbnRyeS9leGl0IGRlY2lzaW9uXG4gICAgfVxuICAgIGF0bi5kZWNpc2lvbk1hcFtidWlsZEFUTktleShydWxlLCBzZXAgPyAnUmVwZXRpdGlvbldpdGhTZXBhcmF0b3InIDogJ1JlcGV0aXRpb24nLCBzdGFyLmlkeCldID0gZW50cnk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogZW50cnksXG4gICAgICAgIHJpZ2h0OiBsb29wRW5kXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG9wdGlvbmFsKGF0biwgcnVsZSwgb3B0aW9uYWwsIGhhbmRsZSkge1xuICAgIGNvbnN0IHN0YXJ0ID0gaGFuZGxlLmxlZnQ7XG4gICAgY29uc3QgZW5kID0gaGFuZGxlLnJpZ2h0O1xuICAgIGVwc2lsb24oc3RhcnQsIGVuZCk7XG4gICAgYXRuLmRlY2lzaW9uTWFwW2J1aWxkQVROS2V5KHJ1bGUsICdPcHRpb24nLCBvcHRpb25hbC5pZHgpXSA9IHN0YXJ0O1xuICAgIHJldHVybiBoYW5kbGU7XG59XG5mdW5jdGlvbiBkZWZpbmVEZWNpc2lvblN0YXRlKGF0biwgc3RhdGUpIHtcbiAgICBhdG4uZGVjaXNpb25TdGF0ZXMucHVzaChzdGF0ZSk7XG4gICAgc3RhdGUuZGVjaXNpb24gPSBhdG4uZGVjaXNpb25TdGF0ZXMubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gc3RhdGUuZGVjaXNpb247XG59XG5mdW5jdGlvbiBtYWtlQWx0cyhhdG4sIHJ1bGUsIHN0YXJ0LCBwcm9kdWN0aW9uLCAuLi5hbHRzKSB7XG4gICAgY29uc3QgZW5kID0gbmV3U3RhdGUoYXRuLCBydWxlLCBwcm9kdWN0aW9uLCB7XG4gICAgICAgIHR5cGU6IEFUTl9CTE9DS19FTkQsXG4gICAgICAgIHN0YXJ0XG4gICAgfSk7XG4gICAgc3RhcnQuZW5kID0gZW5kO1xuICAgIGZvciAoY29uc3QgYWx0IG9mIGFsdHMpIHtcbiAgICAgICAgaWYgKGFsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBob29rIGFsdHMgdXAgdG8gZGVjaXNpb24gYmxvY2tcbiAgICAgICAgICAgIGVwc2lsb24oc3RhcnQsIGFsdC5sZWZ0KTtcbiAgICAgICAgICAgIGVwc2lsb24oYWx0LnJpZ2h0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXBzaWxvbihzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBoYW5kbGUgPSB7XG4gICAgICAgIGxlZnQ6IHN0YXJ0LFxuICAgICAgICByaWdodDogZW5kXG4gICAgfTtcbiAgICBhdG4uZGVjaXNpb25NYXBbYnVpbGRBVE5LZXkocnVsZSwgZ2V0UHJvZFR5cGUocHJvZHVjdGlvbiksIHByb2R1Y3Rpb24uaWR4KV0gPSBzdGFydDtcbiAgICByZXR1cm4gaGFuZGxlO1xufVxuZnVuY3Rpb24gZ2V0UHJvZFR5cGUocHJvZHVjdGlvbikge1xuICAgIGlmIChwcm9kdWN0aW9uIGluc3RhbmNlb2YgQWx0ZXJuYXRpb24pIHtcbiAgICAgICAgcmV0dXJuICdBbHRlcm5hdGlvbic7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2R1Y3Rpb24gaW5zdGFuY2VvZiBPcHRpb24pIHtcbiAgICAgICAgcmV0dXJuICdPcHRpb24nO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kdWN0aW9uIGluc3RhbmNlb2YgUmVwZXRpdGlvbikge1xuICAgICAgICByZXR1cm4gJ1JlcGV0aXRpb24nO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kdWN0aW9uIGluc3RhbmNlb2YgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuICdSZXBldGl0aW9uV2l0aFNlcGFyYXRvcic7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2R1Y3Rpb24gaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5KSB7XG4gICAgICAgIHJldHVybiAnUmVwZXRpdGlvbk1hbmRhdG9yeSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2R1Y3Rpb24gaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gJ1JlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcm9kdWN0aW9uIHR5cGUgZW5jb3VudGVyZWQnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYWtlQmxvY2soYXRuLCBhbHRzKSB7XG4gICAgY29uc3QgYWx0c0xlbmd0aCA9IGFsdHMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWx0c0xlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBjb25zdCBoYW5kbGUgPSBhbHRzW2ldO1xuICAgICAgICBsZXQgdHJhbnNpdGlvbjtcbiAgICAgICAgaWYgKGhhbmRsZS5sZWZ0LnRyYW5zaXRpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdHJhbnNpdGlvbiA9IGhhbmRsZS5sZWZ0LnRyYW5zaXRpb25zWzBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzUnVsZVRyYW5zaXRpb24gPSB0cmFuc2l0aW9uIGluc3RhbmNlb2YgUnVsZVRyYW5zaXRpb247XG4gICAgICAgIGNvbnN0IHJ1bGVUcmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcbiAgICAgICAgY29uc3QgbmV4dCA9IGFsdHNbaSArIDFdLmxlZnQ7XG4gICAgICAgIGlmIChoYW5kbGUubGVmdC50eXBlID09PSBBVE5fQkFTSUMgJiZcbiAgICAgICAgICAgIGhhbmRsZS5yaWdodC50eXBlID09PSBBVE5fQkFTSUMgJiZcbiAgICAgICAgICAgIHRyYW5zaXRpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKChpc1J1bGVUcmFuc2l0aW9uICYmIHJ1bGVUcmFuc2l0aW9uLmZvbGxvd1N0YXRlID09PSBoYW5kbGUucmlnaHQpIHx8XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi50YXJnZXQgPT09IGhhbmRsZS5yaWdodCkpIHtcbiAgICAgICAgICAgIC8vIHdlIGNhbiBhdm9pZCBlcHNpbG9uIGVkZ2UgdG8gbmV4dCBlbGVtZW50XG4gICAgICAgICAgICBpZiAoaXNSdWxlVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgIHJ1bGVUcmFuc2l0aW9uLmZvbGxvd1N0YXRlID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24udGFyZ2V0ID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbW92ZVN0YXRlKGF0biwgaGFuZGxlLnJpZ2h0KTsgLy8gd2Ugc2tpcHBlZCBvdmVyIHRoaXMgc3RhdGVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5lZWQgZXBzaWxvbiBpZiBwcmV2aW91cyBibG9jaydzIHJpZ2h0IGVuZCBub2RlIGlzIGNvbXBsZXhcbiAgICAgICAgICAgIGVwc2lsb24oaGFuZGxlLnJpZ2h0LCBuZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmaXJzdCA9IGFsdHNbMF07XG4gICAgY29uc3QgbGFzdCA9IGFsdHNbYWx0c0xlbmd0aCAtIDFdO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IGZpcnN0LmxlZnQsXG4gICAgICAgIHJpZ2h0OiBsYXN0LnJpZ2h0XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRva2VuUmVmKGF0biwgcnVsZSwgdG9rZW5UeXBlLCBwcm9kdWN0aW9uKSB7XG4gICAgY29uc3QgbGVmdCA9IG5ld1N0YXRlKGF0biwgcnVsZSwgcHJvZHVjdGlvbiwge1xuICAgICAgICB0eXBlOiBBVE5fQkFTSUNcbiAgICB9KTtcbiAgICBjb25zdCByaWdodCA9IG5ld1N0YXRlKGF0biwgcnVsZSwgcHJvZHVjdGlvbiwge1xuICAgICAgICB0eXBlOiBBVE5fQkFTSUNcbiAgICB9KTtcbiAgICBhZGRUcmFuc2l0aW9uKGxlZnQsIG5ldyBBdG9tVHJhbnNpdGlvbihyaWdodCwgdG9rZW5UeXBlKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdCxcbiAgICAgICAgcmlnaHRcbiAgICB9O1xufVxuZnVuY3Rpb24gcnVsZVJlZihhdG4sIGN1cnJlbnRSdWxlLCBub25UZXJtaW5hbCkge1xuICAgIGNvbnN0IHJ1bGUgPSBub25UZXJtaW5hbC5yZWZlcmVuY2VkUnVsZTtcbiAgICBjb25zdCBzdGFydCA9IGF0bi5ydWxlVG9TdGFydFN0YXRlLmdldChydWxlKTtcbiAgICBjb25zdCBsZWZ0ID0gbmV3U3RhdGUoYXRuLCBjdXJyZW50UnVsZSwgbm9uVGVybWluYWwsIHtcbiAgICAgICAgdHlwZTogQVROX0JBU0lDXG4gICAgfSk7XG4gICAgY29uc3QgcmlnaHQgPSBuZXdTdGF0ZShhdG4sIGN1cnJlbnRSdWxlLCBub25UZXJtaW5hbCwge1xuICAgICAgICB0eXBlOiBBVE5fQkFTSUNcbiAgICB9KTtcbiAgICBjb25zdCBjYWxsID0gbmV3IFJ1bGVUcmFuc2l0aW9uKHN0YXJ0LCBydWxlLCByaWdodCk7XG4gICAgYWRkVHJhbnNpdGlvbihsZWZ0LCBjYWxsKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0LFxuICAgICAgICByaWdodFxuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZFJ1bGVIYW5kbGUoYXRuLCBydWxlLCBibG9jaykge1xuICAgIGNvbnN0IHN0YXJ0ID0gYXRuLnJ1bGVUb1N0YXJ0U3RhdGUuZ2V0KHJ1bGUpO1xuICAgIGVwc2lsb24oc3RhcnQsIGJsb2NrLmxlZnQpO1xuICAgIGNvbnN0IHN0b3AgPSBhdG4ucnVsZVRvU3RvcFN0YXRlLmdldChydWxlKTtcbiAgICBlcHNpbG9uKGJsb2NrLnJpZ2h0LCBzdG9wKTtcbiAgICBjb25zdCBoYW5kbGUgPSB7XG4gICAgICAgIGxlZnQ6IHN0YXJ0LFxuICAgICAgICByaWdodDogc3RvcFxuICAgIH07XG4gICAgcmV0dXJuIGhhbmRsZTtcbn1cbmZ1bmN0aW9uIGVwc2lsb24oYSwgYikge1xuICAgIGNvbnN0IHRyYW5zaXRpb24gPSBuZXcgRXBzaWxvblRyYW5zaXRpb24oYik7XG4gICAgYWRkVHJhbnNpdGlvbihhLCB0cmFuc2l0aW9uKTtcbn1cbmZ1bmN0aW9uIG5ld1N0YXRlKGF0biwgcnVsZSwgcHJvZHVjdGlvbiwgcGFydGlhbCkge1xuICAgIGNvbnN0IHQgPSBPYmplY3QuYXNzaWduKHsgYXRuLFxuICAgICAgICBwcm9kdWN0aW9uLCBlcHNpbG9uT25seVRyYW5zaXRpb25zOiBmYWxzZSwgcnVsZSwgdHJhbnNpdGlvbnM6IFtdLCBuZXh0VG9rZW5XaXRoaW5SdWxlOiBbXSwgc3RhdGVOdW1iZXI6IGF0bi5zdGF0ZXMubGVuZ3RoIH0sIHBhcnRpYWwpO1xuICAgIGF0bi5zdGF0ZXMucHVzaCh0KTtcbiAgICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb24oc3RhdGUsIHRyYW5zaXRpb24pIHtcbiAgICAvLyBBIHNpbmdsZSBBVE4gc3RhdGUgY2FuIG9ubHkgY29udGFpbiBlcHNpbG9uIHRyYW5zaXRpb25zIG9yIG5vbi1lcHNpbG9uIHRyYW5zaXRpb25zXG4gICAgLy8gQmVjYXVzZSB0aGV5IGFyZSBuZXZlciBtaXhlZCwgb25seSBzZXR0aW5nIHRoZSBwcm9wZXJ0eSBmb3IgdGhlIGZpcnN0IHRyYW5zaXRpb24gaXMgZmluZVxuICAgIGlmIChzdGF0ZS50cmFuc2l0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc3RhdGUuZXBzaWxvbk9ubHlUcmFuc2l0aW9ucyA9IHRyYW5zaXRpb24uaXNFcHNpbG9uKCk7XG4gICAgfVxuICAgIHN0YXRlLnRyYW5zaXRpb25zLnB1c2godHJhbnNpdGlvbik7XG59XG5mdW5jdGlvbiByZW1vdmVTdGF0ZShhdG4sIHN0YXRlKSB7XG4gICAgYXRuLnN0YXRlcy5zcGxpY2UoYXRuLnN0YXRlcy5pbmRleE9mKHN0YXRlKSwgMSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdG4uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain-allstar/lib/atn.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain-allstar/lib/dfa.js":
/*!****************************************************!*\
  !*** ./node_modules/chevrotain-allstar/lib/dfa.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ATNConfigSet: () => (/* binding */ ATNConfigSet),\n/* harmony export */   DFA_ERROR: () => (/* binding */ DFA_ERROR),\n/* harmony export */   getATNConfigKey: () => (/* binding */ getATNConfigKey)\n/* harmony export */ });\n/* harmony import */ var lodash_es_map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash-es/map.js */ \"(ssr)/./node_modules/lodash-es/map.js\");\n/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nconst DFA_ERROR = {};\nclass ATNConfigSet {\n    constructor() {\n        this.map = {};\n        this.configs = [];\n    }\n    get size() {\n        return this.configs.length;\n    }\n    finalize() {\n        // Empties the map to free up memory\n        this.map = {};\n    }\n    add(config) {\n        const key = getATNConfigKey(config);\n        // Only add configs which don't exist in our map already\n        // While this does not influence the actual algorithm, adding them anyway would massively increase memory consumption\n        if (!(key in this.map)) {\n            this.map[key] = this.configs.length;\n            this.configs.push(config);\n        }\n    }\n    get elements() {\n        return this.configs;\n    }\n    get alts() {\n        return (0,lodash_es_map_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.configs, (e) => e.alt);\n    }\n    get key() {\n        let value = \"\";\n        for (const k in this.map) {\n            value += k + \":\";\n        }\n        return value;\n    }\n}\nfunction getATNConfigKey(config, alt = true) {\n    return `${alt ? `a${config.alt}` : \"\"}s${config.state.stateNumber}:${config.stack.map((e) => e.stateNumber.toString()).join(\"_\")}`;\n}\n//# sourceMappingURL=dfa.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi1hbGxzdGFyL2xpYi9kZmEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDbUM7QUFDNUI7QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNERBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxjQUFjLFVBQVUsV0FBVyxPQUFPLEdBQUcseUJBQXlCLEdBQUcsNERBQTREO0FBQ3JJO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9uYWthaWtlbnRvL25vdGUtYWdlbnQvbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4tYWxsc3Rhci9saWIvZGZhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIyIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCBtYXAgZnJvbSBcImxvZGFzaC1lcy9tYXAuanNcIjtcbmV4cG9ydCBjb25zdCBERkFfRVJST1IgPSB7fTtcbmV4cG9ydCBjbGFzcyBBVE5Db25maWdTZXQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1hcCA9IHt9O1xuICAgICAgICB0aGlzLmNvbmZpZ3MgPSBbXTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3MubGVuZ3RoO1xuICAgIH1cbiAgICBmaW5hbGl6ZSgpIHtcbiAgICAgICAgLy8gRW1wdGllcyB0aGUgbWFwIHRvIGZyZWUgdXAgbWVtb3J5XG4gICAgICAgIHRoaXMubWFwID0ge307XG4gICAgfVxuICAgIGFkZChjb25maWcpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZ2V0QVROQ29uZmlnS2V5KGNvbmZpZyk7XG4gICAgICAgIC8vIE9ubHkgYWRkIGNvbmZpZ3Mgd2hpY2ggZG9uJ3QgZXhpc3QgaW4gb3VyIG1hcCBhbHJlYWR5XG4gICAgICAgIC8vIFdoaWxlIHRoaXMgZG9lcyBub3QgaW5mbHVlbmNlIHRoZSBhY3R1YWwgYWxnb3JpdGhtLCBhZGRpbmcgdGhlbSBhbnl3YXkgd291bGQgbWFzc2l2ZWx5IGluY3JlYXNlIG1lbW9yeSBjb25zdW1wdGlvblxuICAgICAgICBpZiAoIShrZXkgaW4gdGhpcy5tYXApKSB7XG4gICAgICAgICAgICB0aGlzLm1hcFtrZXldID0gdGhpcy5jb25maWdzLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuY29uZmlncy5wdXNoKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGVsZW1lbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWdzO1xuICAgIH1cbiAgICBnZXQgYWx0cygpIHtcbiAgICAgICAgcmV0dXJuIG1hcCh0aGlzLmNvbmZpZ3MsIChlKSA9PiBlLmFsdCk7XG4gICAgfVxuICAgIGdldCBrZXkoKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IFwiXCI7XG4gICAgICAgIGZvciAoY29uc3QgayBpbiB0aGlzLm1hcCkge1xuICAgICAgICAgICAgdmFsdWUgKz0gayArIFwiOlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QVROQ29uZmlnS2V5KGNvbmZpZywgYWx0ID0gdHJ1ZSkge1xuICAgIHJldHVybiBgJHthbHQgPyBgYSR7Y29uZmlnLmFsdH1gIDogXCJcIn1zJHtjb25maWcuc3RhdGUuc3RhdGVOdW1iZXJ9OiR7Y29uZmlnLnN0YWNrLm1hcCgoZSkgPT4gZS5zdGF0ZU51bWJlci50b1N0cmluZygpKS5qb2luKFwiX1wiKX1gO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGZhLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain-allstar/lib/dfa.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain-allstar/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/chevrotain-allstar/lib/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LLStarLookaheadStrategy: () => (/* reexport safe */ _all_star_lookahead_js__WEBPACK_IMPORTED_MODULE_0__.LLStarLookaheadStrategy)\n/* harmony export */ });\n/* harmony import */ var _all_star_lookahead_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./all-star-lookahead.js */ \"(ssr)/./node_modules/chevrotain-allstar/lib/all-star-lookahead.js\");\n/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi1hbGxzdGFyL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0U7QUFDbEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9uYWthaWtlbnRvL25vdGUtYWdlbnQvbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4tYWxsc3Rhci9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjIgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZXhwb3J0IHsgTExTdGFyTG9va2FoZWFkU3RyYXRlZ3kgfSBmcm9tICcuL2FsbC1zdGFyLWxvb2thaGVhZC5qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain-allstar/lib/index.js\n");

/***/ })

};
;